<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Intro_to_jujutsu | NixOS Blog</title><meta name=keywords content><meta name=description content="Intro to Jujutsu (Using jj in an existing Git Repo)



You can use jujutsu (jj) with existing Git repositories with one command.
jj git init --colocate or jj git init --git-repo /path/to/git_repository.
The native repository format for jj is still a work in progress so people
typically use a git repository for backend.


Unlike git, jj has no index &ldquo;staging area&rdquo;. It treats the working copy
as an actual commit. When you make changes to files, these changes are
automatically recorded to the working commit. There&rsquo;s no need to explicitly
stage changes because they are already part of the commit that represents
your current working state."><meta name=author content="T Sawyer"><link rel=canonical href=https://tsawyer87.github.io/posts/intro_to_jujutsu/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://tsawyer87.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://tsawyer87.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://tsawyer87.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://tsawyer87.github.io/apple-touch-icon.png><link rel=mask-icon href=https://tsawyer87.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://tsawyer87.github.io/posts/intro_to_jujutsu/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://tsawyer87.github.io/posts/intro_to_jujutsu/"><meta property="og:site_name" content="NixOS Blog"><meta property="og:title" content="Intro_to_jujutsu"><meta property="og:description" content="Intro to Jujutsu (Using jj in an existing Git Repo) You can use jujutsu (jj) with existing Git repositories with one command. jj git init --colocate or jj git init --git-repo /path/to/git_repository. The native repository format for jj is still a work in progress so people typically use a git repository for backend.
Unlike git, jj has no index “staging area”. It treats the working copy as an actual commit. When you make changes to files, these changes are automatically recorded to the working commit. There’s no need to explicitly stage changes because they are already part of the commit that represents your current working state."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-14T19:07:59-04:00"><meta property="article:modified_time" content="2025-05-14T19:07:59-04:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Intro_to_jujutsu"><meta name=twitter:description content="Intro to Jujutsu (Using jj in an existing Git Repo)



You can use jujutsu (jj) with existing Git repositories with one command.
jj git init --colocate or jj git init --git-repo /path/to/git_repository.
The native repository format for jj is still a work in progress so people
typically use a git repository for backend.


Unlike git, jj has no index &ldquo;staging area&rdquo;. It treats the working copy
as an actual commit. When you make changes to files, these changes are
automatically recorded to the working commit. There&rsquo;s no need to explicitly
stage changes because they are already part of the commit that represents
your current working state."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tsawyer87.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Intro_to_jujutsu","item":"https://tsawyer87.github.io/posts/intro_to_jujutsu/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Intro_to_jujutsu","name":"Intro_to_jujutsu","description":"Intro to Jujutsu (Using jj in an existing Git Repo) You can use jujutsu (jj) with existing Git repositories with one command. jj git init --colocate or jj git init --git-repo /path/to/git_repository. The native repository format for jj is still a work in progress so people typically use a git repository for backend.\nUnlike git, jj has no index \u0026ldquo;staging area\u0026rdquo;. It treats the working copy as an actual commit. When you make changes to files, these changes are automatically recorded to the working commit. There\u0026rsquo;s no need to explicitly stage changes because they are already part of the commit that represents your current working state.\n","keywords":[],"articleBody":"Intro to Jujutsu (Using jj in an existing Git Repo) You can use jujutsu (jj) with existing Git repositories with one command. jj git init --colocate or jj git init --git-repo /path/to/git_repository. The native repository format for jj is still a work in progress so people typically use a git repository for backend.\nUnlike git, jj has no index “staging area”. It treats the working copy as an actual commit. When you make changes to files, these changes are automatically recorded to the working commit. There’s no need to explicitly stage changes because they are already part of the commit that represents your current working state.\nThis means that you don’t need to worry about making a change, running git add ., running git commit -m \"commit message\" because it’s already done for you. This is handy with flakes by preventing a “dirty working tree” and can instantly be rebuilt after making a change. Here’s an example Say I have my configuration flake in the ~/flakes/ directory that is an existing Git repository. To use JJ as the front-end I could do something like:\ncd ~/flakes jj git init --colocate jj describe -m \"first jj commit\" jj commit Or to do this in a directory that isn’t already a git repo you can do something like:\ncargo new hello-world --vcs=none cd hello-world jj git init Initialized repo in \".\" JJ and Git Side by Side Or for example, with Git if you wanted to move to a different branch before running nix flake update to see if it introduced errors before merging with your main branch, you could do something like:\ngit checkout -b update-test nix flake update sudo nixos-rebuild test --flake . If you’re satisfied you can merge:\ngit checkout main git add . # Stage the change git commit -m \"update\" git branch -D update-test git merge update-test sudo nixos-rebuild switch --flake . With JJ a similar workflow could be:\njj new # Create a new child commit/start working on a new change nix flake update sudo nixos-rebuild test --flake . jj squash # equivalent to `git commit -a --amend` jj describe -m \"update\" # Similar to git commit -m jj commit # Only needed if finalizing an explicit commit sudo nixos-rebuild switch --flake . With jj you’re creating a new commit rather than a new branch.\nAmending vs. Squashing: Git’s git commit --amend updates the last commit. jj squash combines the current commit with its parent, effectively doing the same thing in terms of history.\nMerging: Git’s merge command is explicit. In jj, the concept is similar, but since there’s no branch, you’re “merging” by moving your working commit to include these changes. The jj squash here acts like merging the changes into the main line of development.\nNo need to delete branches: Since there are no branches in jj, there’s no equivalent to git branch -D to clean up. Instead commits that are no longer needed can be “abandoned” with jj abandon if you want to clean up your commit graph.\njj describe without a flag just opens $EDITOR where you can write your commit message save and exit.\nIn git, we finish a set of changes to our code by committing, but in jj we start new work by creating a change, and then make changes to our code. It’s more useful to write an initial description of your intended changes, and then refine it as you work, than it is creating a commit message after the fact.\nI have heard that jj can struggle with big repositories such as Nixpkgs and have noticed some issues here and there when using with NixOS. I’m hoping that as the project matures,it gets better on this front.\nThis is just the start of what is possible, here are some resources about it if you’re interested:\nResources jj_github\nofficial_tutorial\njj_init # very good article\nsteves_jj_tutorial\n","wordCount":"647","inLanguage":"en","datePublished":"2025-05-14T19:07:59-04:00","dateModified":"2025-05-14T19:07:59-04:00","author":{"@type":"Person","name":"T Sawyer"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://tsawyer87.github.io/posts/intro_to_jujutsu/"},"publisher":{"@type":"Organization","name":"NixOS Blog","logo":{"@type":"ImageObject","url":"https://tsawyer87.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tsawyer87.github.io/ accesskey=h title="NixOS Blog (Alt + H)">NixOS Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
<a href=/index.xml title="RSS Feed"><img src=/rss.png alt="RSS Feed" style=width:24px;height:24px></a></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Intro_to_jujutsu</h1><div class=post-meta><span title='2025-05-14 19:07:59 -0400 EDT'>May 14, 2025</span>&nbsp;·&nbsp;T Sawyer</div></header><div class=post-content><h1 id=intro-to-jujutsu-using-jj-in-an-existing-git-repo>Intro to Jujutsu (Using jj in an existing Git Repo)<a hidden class=anchor aria-hidden=true href=#intro-to-jujutsu-using-jj-in-an-existing-git-repo>#</a></h1><p><img alt="Jujutsu Logo" loading=lazy src=/images/jujutsu.png></p><ul><li><p>You can use jujutsu (jj) with existing Git repositories with one command.
<code>jj git init --colocate</code> or <code>jj git init --git-repo /path/to/git_repository</code>.
The native repository format for jj is still a work in progress so people
typically use a <code>git</code> repository for backend.</p></li><li><p>Unlike <code>git</code>, <code>jj</code> has no index &ldquo;staging area&rdquo;. It treats the working copy
as an actual commit. When you make changes to files, these changes are
automatically recorded to the working commit. There&rsquo;s no need to explicitly
stage changes because they are already part of the commit that represents
your current working state.</p><ul><li>This means that you don&rsquo;t need to worry about making a change, running
<code>git add .</code>, running <code>git commit -m "commit message"</code> because it&rsquo;s
already done for you. This is handy with flakes by preventing a
&ldquo;dirty working tree&rdquo; and can instantly be rebuilt after making a change.</li></ul></li></ul><h2 id=heres-an-example>Here&rsquo;s an example<a hidden class=anchor aria-hidden=true href=#heres-an-example>#</a></h2><p>Say I have my configuration flake in the <code>~/flakes/</code> directory that is an
existing Git repository. To use JJ as the front-end I could do something like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cd ~/flakes
</span></span><span style=display:flex><span>jj git init --colocate
</span></span><span style=display:flex><span>jj describe -m <span style=color:#e6db74>&#34;first jj commit&#34;</span>
</span></span><span style=display:flex><span>jj commit
</span></span></code></pre></div><p><strong>Or</strong> to do this in a directory that isn&rsquo;t already a git repo you can do
something like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cargo new hello-world --vcs<span style=color:#f92672>=</span>none
</span></span><span style=display:flex><span>cd hello-world
</span></span><span style=display:flex><span>jj git init
</span></span><span style=display:flex><span>Initialized repo in <span style=color:#e6db74>&#34;.&#34;</span>
</span></span></code></pre></div><h3 id=jj-and-git-side-by-side>JJ and Git Side by Side<a hidden class=anchor aria-hidden=true href=#jj-and-git-side-by-side>#</a></h3><p>Or for example, with Git if you wanted to move to a different branch before
running <code>nix flake update</code> to see if it introduced errors before merging
with your main branch, you could do something like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git checkout -b update-test
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>nix flake update
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>sudo nixos-rebuild test --flake .
</span></span></code></pre></div><p>If you&rsquo;re satisfied you can merge:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git checkout main
</span></span><span style=display:flex><span>git add . <span style=color:#75715e># Stage the change</span>
</span></span><span style=display:flex><span>git commit -m <span style=color:#e6db74>&#34;update&#34;</span>
</span></span><span style=display:flex><span>git branch -D update-test
</span></span><span style=display:flex><span>git merge update-test
</span></span><span style=display:flex><span>sudo nixos-rebuild switch --flake .
</span></span></code></pre></div><p>With JJ a similar workflow could be:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>jj new  <span style=color:#75715e># Create a new child commit/start working on a new change</span>
</span></span><span style=display:flex><span>nix flake update
</span></span><span style=display:flex><span>sudo nixos-rebuild test --flake .
</span></span><span style=display:flex><span>jj squash <span style=color:#75715e>#  equivalent to `git commit -a --amend`</span>
</span></span><span style=display:flex><span>jj describe -m <span style=color:#e6db74>&#34;update&#34;</span> <span style=color:#75715e># Similar to git commit -m</span>
</span></span><span style=display:flex><span>jj commit <span style=color:#75715e># Only needed if finalizing an explicit commit</span>
</span></span><span style=display:flex><span>sudo nixos-rebuild switch --flake .
</span></span></code></pre></div><ul><li><p>With <code>jj</code> you&rsquo;re creating a new commit rather than a new branch.</p></li><li><p>Amending vs. Squashing: Git&rsquo;s <code>git commit --amend</code> updates the last commit.
<code>jj squash</code> combines the current commit with its parent, effectively doing
the same thing in terms of history.</p></li><li><p>Merging: Git&rsquo;s merge command is explicit. In <code>jj</code>, the concept is similar,
but since there&rsquo;s no branch, you&rsquo;re &ldquo;merging&rdquo; by moving your working commit
to include these changes. The <code>jj squash</code> here acts like merging the changes
into the main line of development.</p></li><li><p>No need to delete branches: Since there are no branches in <code>jj</code>, there&rsquo;s
no equivalent to <code>git branch -D</code> to clean up. Instead commits that are no
longer needed can be &ldquo;abandoned&rdquo; with <code>jj abandon</code> if you want to clean up
your commit graph.</p></li><li><p><code>jj describe</code> without a flag just opens <code>$EDITOR</code> where you can write your
commit message save and exit.</p></li><li><p>In <code>git</code>, we finish a set of changes to our code by committing, but in
<code>jj</code> we start new work by creating a change, and <em>then</em> make changes to
our code. It&rsquo;s more useful to write an initial description of your intended
changes, and then refine it as you work, than it is creating a commit message
after the fact.</p></li><li><p>I have heard that jj can struggle with big repositories such as Nixpkgs and
have noticed some issues here and there when using with NixOS.
I&rsquo;m hoping that as the project matures,it gets better on this front.</p></li><li><p>This is just the start of what is possible, here are some resources about
it if you&rsquo;re interested:</p></li></ul><h3 id=resources>Resources<a hidden class=anchor aria-hidden=true href=#resources>#</a></h3><ul><li><p><a href=https://github.com/jj-vcs/jj>jj_github</a></p></li><li><p><a href=https://jj-vcs.github.io/jj/latest/tutorial/>official_tutorial</a></p></li><li><p><a href=https://v5.chriskrycho.com/essays/jj-init/>jj_init</a> # very good article</p></li><li><p><a href=https://steveklabnik.github.io/jujutsu-tutorial/>steves_jj_tutorial</a></p></li></ul></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://tsawyer87.github.io/>NixOS Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>