<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Using_nushell_with_nixos | NixOS Blog</title><meta name=keywords content><meta name=description content="Nushell and NixOS

     




TL;DR:I recently switched default shells from zsh to nushell, this post
is about some of the challenges and advantages of using nushell with NixOS.


While the average user might not immediately see significant advantages, those
who frequently work with structured data formats like JSON, YAML, and CSV –
such as developers interacting with APIs, system administrators managing
configurations, and data professionals – will likely find Nushell&rsquo;s native
data handling and powerful pipeline capabilities a plus. Additionally, users
who value a more consistent and safer scripting experience might appreciate
Nushell&rsquo;s language-first design and features like strong typing."><meta name=author content><link rel=canonical href=https://tsawyer87.github.io/posts/using_nushell_with_nixos/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://tsawyer87.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://tsawyer87.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://tsawyer87.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://tsawyer87.github.io/apple-touch-icon.png><link rel=mask-icon href=https://tsawyer87.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://tsawyer87.github.io/posts/using_nushell_with_nixos/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://tsawyer87.github.io/posts/using_nushell_with_nixos/"><meta property="og:site_name" content="NixOS Blog"><meta property="og:title" content="Using_nushell_with_nixos"><meta property="og:description" content="Nushell and NixOS TL;DR:I recently switched default shells from zsh to nushell, this post is about some of the challenges and advantages of using nushell with NixOS.
While the average user might not immediately see significant advantages, those who frequently work with structured data formats like JSON, YAML, and CSV – such as developers interacting with APIs, system administrators managing configurations, and data professionals – will likely find Nushell’s native data handling and powerful pipeline capabilities a plus. Additionally, users who value a more consistent and safer scripting experience might appreciate Nushell’s language-first design and features like strong typing."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-16T19:54:01-04:00"><meta property="article:modified_time" content="2025-05-16T19:54:01-04:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Using_nushell_with_nixos"><meta name=twitter:description content="Nushell and NixOS

     




TL;DR:I recently switched default shells from zsh to nushell, this post
is about some of the challenges and advantages of using nushell with NixOS.


While the average user might not immediately see significant advantages, those
who frequently work with structured data formats like JSON, YAML, and CSV –
such as developers interacting with APIs, system administrators managing
configurations, and data professionals – will likely find Nushell&rsquo;s native
data handling and powerful pipeline capabilities a plus. Additionally, users
who value a more consistent and safer scripting experience might appreciate
Nushell&rsquo;s language-first design and features like strong typing."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tsawyer87.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Using_nushell_with_nixos","item":"https://tsawyer87.github.io/posts/using_nushell_with_nixos/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Using_nushell_with_nixos","name":"Using_nushell_with_nixos","description":"Nushell and NixOS TL;DR:I recently switched default shells from zsh to nushell, this post is about some of the challenges and advantages of using nushell with NixOS.\nWhile the average user might not immediately see significant advantages, those who frequently work with structured data formats like JSON, YAML, and CSV – such as developers interacting with APIs, system administrators managing configurations, and data professionals – will likely find Nushell\u0026rsquo;s native data handling and powerful pipeline capabilities a plus. Additionally, users who value a more consistent and safer scripting experience might appreciate Nushell\u0026rsquo;s language-first design and features like strong typing.\n","keywords":[],"articleBody":"Nushell and NixOS TL;DR:I recently switched default shells from zsh to nushell, this post is about some of the challenges and advantages of using nushell with NixOS.\nWhile the average user might not immediately see significant advantages, those who frequently work with structured data formats like JSON, YAML, and CSV – such as developers interacting with APIs, system administrators managing configurations, and data professionals – will likely find Nushell’s native data handling and powerful pipeline capabilities a plus. Additionally, users who value a more consistent and safer scripting experience might appreciate Nushell’s language-first design and features like strong typing.\nI’ll start with some of the unique build design choices and unique features that I think make Nushell special, then show an example using Nushell to manipulate JSON data. Finally, I will highlight some of the visually appealing aspects of Nushell and lastly I share some resources for learning more.\nThe Good Nushell borrows concepts from many shells and languages and is itself both a programming language and a shell. Because of this, it has its own way of working with files, directories, websites, and more.\nNushell is powerful and has many essential commands built directly into the shell (“internal” commands) rather than a link to an executable. You can use this set of commands across different operating systems, having this consistency is helpful when creating cross-platform code.\nWhen internal Nushell commands (like ls, open, where, get, sort-by, etc.) produce output, they generally do so in Nushell’s structured data format (tables or records). This is the shell’s native way of representing information.\nBeyond these foundational strengths, Nushell offers a range of unique features that enhance its functionality and make it particularly well-suited for data-heavy tasks. Here are some highlights that showcase its versatility.\nSome Unique Features:\nBesides the built-in commands, Nushell has a standard library Nushell operates on structured data. You could call it a “data-first” shell and programming language.\nAlso included, is a full-featured dataframe processing engine using Polars if you want to process large data efficiently directly in your shell, check out the Dataframes-Docs\nMulti-Line Editing:\nWhen writing a long command you can press Enter to add a newline and move to the next line. For example:\nls | # press enter where name =~ | # press enter, comments after pipe ok get name | # press enter mv ...$in ./backups/ This allows you to cycle through the entire multi-line command using the up and down arrow keys and then customize different lines or sections of the command.\nYou can manually insert a newline using Alt+Enter or Shift+Enter.\nThe Reedline-Editor is powerful and provides good vi-mode or emacs support built in.\nIt’s default Ctrl+r history command is nice to work with out of the box.\nThe explore command, is nu’s version of a table pager, just like less but for table structured data:\n$nu | explore --peek With the above command you can navigate with vim keybinds or arrow keys.\nThese features demonstrate Nushell’s user-friendly interface, but what truly sets it apart is its underlying design as a structured data scripting language. This “language-first” approach powers many of its distinctive capabilities.\nUnique design:\nFundamentally designed as a structured data scripting language: and then it acts as a shell on top of that foundation. This “language first” approach is what gives it many of its distinctive features and makes it a powerful scripting language. I reiterate this here because of the implications of this. A few of those features are:\nPipelines of structured data: Unlike traditional shells that primarily deal with plain text streams, Nushell pipelines operate on tables of structured data. Each command can understand and manipulate this structured data directly.\nConsistent syntax: Its syntax is more consistent and predictable compared to the often quirky syntax of Bash and Zsh, drawing inspiration from other programming languages.\nStrong typing Nushell has a type system, which helps catch errors early and allows for more robust scripting.\nFirst-class data types: It treats various data formats (like JSON, CSV, TOML) as native data types, making it easier to work with them. Because of this, Nushell aims to replace the need for external tools like jq, awk, sed, cut, and even some uses of grep and curl.\nVariables are Immutable by Default: Nushell’s commands are based on a functional-style of programming which requires immutability, sound familiar?\nNushell’s Environment is Scoped: Nushell takes many design cues from compiled languages, one is that languages should avoid global mutable state. Shells have commonly used global mutation to update the environment, Nushell attempts to steer clear of this increasing reproducability.\nSingle-use Environment Variables:\nFOO=BAR $env.FOO # =\u003e BAR Permanent Environment Variables: In your config.nu # config.nu $env.FOO = 'BAR' Coming-From-Bash\nThese design principles make Nushell a powerful tool for scripting, but they’re best understood through a hands-on example. Let’s see how Nushell’s structured data capabilities shine in a common task: processing a JSON file.\nExample: I wanted to provide a practical example to illustrate some of these “Good” features in action. And break it down for better understanding.\nLet’s consider a common task: processing data from a JSON file. Imagine you have a file containing a list of users with their names and ages. With traditional shells, you’d likely need to rely on external tools like jq to parse and filter this data. However, Nushell can handle this directly within its own commands.\nFor this example you could create a test directory and move to it:\nmkdir test ; cd test Create a users.json with the following contents: [ { \"name\": \"Alice\", \"age\": 25 }, { \"name\": \"Bob\", \"age\": 30 }, { \"name\": \"Charlie\", \"age\": 20 } ] And create the following filter.nu that first converts users.json into its own internal structured data format with the open command, then to filters out people under 21 with the where control flow construct, then selects the name and age columns, sorts them by age, and finally converts them back to json and saves them to a file called filtered_users.json. A lot happening in a 6 line script. open users.json # Read JSON file into structured data | where age \u003e 21 # Filter users older than 21 | select name age # Select only name and age columns | sort-by age # Sort by age | to json # Convert back to JSON | save filtered_users.json # Save result to a new file The open command takes data from a file (or even a URL in some cases) and parses it and converts it into Nushells own internal structured data format. So this command isn’t just showing you the contents of users.json but doing a conversion to Nu’s special structured format. open users.json ╭───┬─────────┬─────╮ │ # │ name │ age │ ├───┼─────────┼─────┤ │ 0 │ Alice │ 25 │ │ 1 │ Bob │ 30 │ │ 2 │ Charlie │ 20 │ ╰───┴─────────┴─────╯ The source command in Nushell is used to execute the commands within a script file (like filter.nu) in the current Nushell environment. It’s similar to running the script directly in the shell, but keeps the shell open for further use. In this example, source filter.nu runs the commands inside filter.nu, processing the users.json file and creating the filtered_users.json file: source filter.nu bat filtered_users.json ───────┬────────────────────────────────────────────────────────────────────────────────────── │ File: filtered_users.json ───────┼────────────────────────────────────────────────────────────────────────────────────── 1 │ [ 2 │ { 3 │ \"name\": \"Alice\", 4 │ \"age\": 25 5 │ }, 6 │ { 7 │ \"name\": \"Bob\", 8 │ \"age\": 30 9 │ } 10 │ ] ───────┴─────────────────────────────────────────────────────────────────────────────────── As you can see, without needing any external tools, Nushell was able to read, filter, select, sort, and then re-serialize JSON data using a clear and concise pipeline. This demonstrates its power in handling structured data natively, making common data manipulation tasks within the shell significantly more streamlined and readable compared to traditional approaches. In the filter.nu example:\nopen users.json # Read JSON file into structured data | where age \u003e 21 # Filter users older than 21 | select name age # Select only name and age columns | sort-by age # Sort by age | to json # Convert back to JSON | save filtered_users.json # Save result to a new file open users.json: Produces a Nushell table representing the data.\n| where age \u003e 21: Receives the table, filters rows based on the age column, and outputs a new, filtered table.\n| select name age: Receives the filtered table, selects only the name and age columns, and outputs a table with fewer columns.\n| sort-by age: Receives the table, sorts the rows based on the age column, and outputs a sorted table.\n| to json: Receives the sorted table and converts it back into JSON text.\n| save filtered_users.json: Receives the JSON text and saves it to a file.\nSo, while the concept of piping is the same, the nature of the data flowing through the Nushell pipeline is richer and more structured, enabling more powerful and direct data manipulation.\nWhile Nushell’s strengths, like its structured data pipelines, make it a game-changer for many tasks, it’s not without its challenges, especially when integrated with NixOS’s Bash-centric ecosystem. Let’s explore some of the limitations you might encounter when adopting Nushell as your default shell.\nThe Bad While the project is still maturing, the active community and ongoing improvements are promising. Don’t get too discouraged by the following, there would be a bad section for any shell imo.\nThere are many similarities so it can be easy to forget that some Bash (and POSIX in general) style constructs just won’t work in Nushell. Considering that NixOS seems to have been designed for bash, even Zsh isn’t fully compatable you may want to think twice before you choose Nushell as your default.\nThe documentation is incomplete and written by devs for devs imo, it is quite a bit different from anything else I’ve seen so there is a bit of a learning curve. Nushell is generally still considered to be in a stage where it might not be the most seamless or trouble-free experience as a daily driver default shell for most users, especially on a system like NixOS known for its unique approach.\nThe any-nix-shell project doesn’t include Nushell as with many others because of it’s lack of maturity.\nThe following addition comes from Joey_McKur’s sugggestion, on mentioning the job command as one of the biggest criticisms against Nu because it doesn’t support background tasks. I should also note that Nushell’s team is aware of these criticisms and actively working on improving job control.\nLimited Feature Set Compared to Traditional Job Control:\nLack of Full POSIX Job Control: Nushell’s job control doesn’t yet fully implement all the features and signals defined by POSIX job control (e.g., more nuanced signal handling, stopped jobs). While it covers the basics, users accustomed to advanced Bash job control might find it lacking.\nForegrounding Behavior: There have been criticisms about how foregrounding jobs interacts with the terminal and potential issues with signal propagation.\nOutput Handling Challenges:\nInterleaved Output: Managing the output of multiple backgrounded jobs can sometimes be messy, with output from different jobs potentially interleaving in the terminal. While Nushell tries to handle this, it’s not always as clean as desired.\nRedirection Complexity: Redirecting the input and output of backgrounded jobs can be less straightforward than in Bash, sometimes requiring more explicit handling.\nIntegration with Pipelines:\nBackgrounding Pipelines: Backgrounding complex pipelines with multiple stages can sometimes lead to unexpected behavior or difficulties in managing the entire pipeline as a single job. Error Reporting:\nDifficult to Track Errors in Background Jobs: Identifying and debugging errors in backgrounded jobs can be less direct than with foreground processes, and the job command’s output might not always provide sufficient information for troubleshooting.\nMany of Nushell’s challenges stem from its departure from traditional shell conventions, particularly those of Bash, which NixOS heavily relies on. To better understand these differences and how they impact your workflow, let’s compare Nushell’s static, structured approach to Bash’s dynamic, text-based model.\nKey Differences Between Nushell \u0026 Bash Feature Bash (Dynamic) Nushell (Static) Code Execution Line-by-line Whole script parsed first Error Detection Runtime errors only Catches errors before running Support for eval ✅ Allowed ❌ Not supported Custom Parsing Limited Built-in semantic analysis IDE Features Basic syntax highlighting Advanced integration, linting, and formatting \u0026\u0026 doesn’t work use ; instead.\n\u003e is used as the greater-than operator for comparisons:\n\"hello\" | save output.txt is equivalent to the following in bash:\necho \"hello\" \u003e output.txt If you notice above the nushell command doesn’t require an echo prefix, this is because Nushell has Implicit Return: \"Hello, World\" == (echo \"Hello, World\") # =\u003e true The above example shows that the string, \"Hello, World\" is equivalent to the output value from echo \"Hello, World\"\nEvery Command Returns a Value:\nlet p = 7 print $p # 7 $p * 6 # 42 Understanding these differences highlights why Nushell feels so distinct from Bash, but it’s the shell’s advanced features and integrations that truly make it shine. Let’s dive into some of the beautiful and powerful tools and custom commands that elevate Nushell for NixOS users. The Beautiful and Powerful Ctrl+t List Commands with carapace and fzf:\nCarapace Carapace-Bin Install:\nCarapace man example:\nCustom Nushell Commands\nThe following command allows you to choose which input to update interactively with fzf. # nix.nu # upgrade system packages # `nix-upgrade` or `nix-upgrade -i` def nix-upgrade [ flake_path: string = \"/home/jr/flake\", # path that contains a flake.nix --interactive (-i) # select packages to upgrade interactively ]: nothing -\u003e nothing { let working_path = $flake_path | path expand if not ($working_path | path exists) { echo \"path does not exist: $working_path\" exit 1 } let pwd = $env.PWD cd $working_path if $interactive { let selections = nix flake metadata . --json | from json | get locks.nodes | columns | str join \"\\n\" | fzf --multi --tmux center,20% | lines # Debug: Print selections to verify print $\"Selections: ($selections)\" # Check if selections is empty if ($selections | is-empty) { print \"No selections made.\" cd $pwd return } # Use spread operator to pass list items as separate arguments nix flake update ...$selections } else { nix flake update } cd $pwd nh os switch $working_path } The ns command is designed to search for Nix packages using nix search and present the results in a cleaner format, specifically removing the architecture and operating system prefix that nix search often includes. def ns [ term: string # Search target. ] { let info = ( sysctl -n kernel.arch kernel.ostype | lines | {arch: ($in.0|str downcase), ostype: ($in.1|str downcase)} ) nix search --json nixpkgs $term | from json | transpose package description | flatten | select package description version | update package {|row| $row.package | str replace $\"legacyPackages.($info.arch)-($info.ostype).\" \"\"} } nufetch command: # `nufetch` `(nufetch).packages` def nufetch [] { { \"kernel\": $nu.os-info.kernel_version, \"nu\": $env.NU_VERSION, \"packages\": (ls /etc/profiles/per-user | select name | prepend [[name]; [\"/run/current-system/sw\"]] | each { insert \"number\" (nix path-info --recursive ($in | get name) | lines | length) | insert \"size\" ( nix path-info -S ($in | get name) | parse -r '\\s(.*)' | get capture0.0 | into filesize) | update \"name\" ($in | get name | parse -r '.*/(.*)' | get capture0.0 | if $in == \"sw\" {\"system\"} else {$in}) | rename \"environment\"}), \"uptime\": (sys host).uptime } } duf command, I have mine aliased to df: ps command: Adding the following to your configuration.nix will show you the diff of the closures on rebuild: # configuration.nix # During system activation, compare the closure size difference between the # current and new system and display a formatted table if significant changes are # detected. system.activationScripts.diff = '' if [[ -e /run/current-system ]]; then ${pkgs.nushell}/bin/nu -c \"let diff_closure = (${pkgs.nix}/bin/nix store diff-closures /run/current-system '$systemConfig'); let table = (\\$diff_closure | lines | where \\$it =~ KiB | where \\$it =~ → | parse -r '^(?\\S+): (?[^,]+)(?:.*) → (?[^,]+)(?:.*), (?.*)$' | insert Diff { get DiffBin | ansi strip | into filesize } | sort-by -r Diff | reject DiffBin); if (\\$table | get Diff | is-not-empty) { print \\\"\\\"; \\$table | append [[Package Old New Diff]; [\\\"\\\" \\\"\\\" \\\"\\\" \\\"\\\"]] | append [[Package Old New Diff]; [\\\"\\\" \\\"\\\" \\\"Total:\\\" (\\$table | get Diff | math sum) ]] | print; print \\\"\\\" }\" fi ''; nix-list-system command lists all installed packages: # list all installed packages def nix-list-system []: nothing -\u003e list { ^nix-store -q --references /run/current-system/sw | lines | filter { not ($in | str ends-with 'man') } | each { $in | str replace -r '^[^-]*-' '' } | sort } These custom Nushell commands showcase its flexibility, but sometimes you need to work around Nushell’s limitations, like compatability with certain NixOS tools. This is where just and justfiles come in, simplifying complex workflows and bridging gaps in Nushell’s functionality. Using Just and Justfiles The following is my justfile that I keep right next to my flake.nix it simplifies some commands and makes things work that weren’t working with nushell for my case, you’ll have to change it to match your configuration. It’s not perfect but works for my use case, take whats useful and leave the rest.\nYou’ll first need to install just to make use of justfiles.\n# nix shell nixpkgs#just nixpkgs#nushell set shell := [\"nu\", \"-c\"] flake_path := \"/home/jr/flake\" hostname := \"magic\" home_manager_output := \"jr@magic\" utils_nu := absolute_path(\"utils.nu\") default: @just --list # Rebuild [group('nix')] fr: nh os switch --hostname {{hostname}} {{flake_path}} # Flake Update [group('nix')] fu: nh os switch --hostname {{hostname}} --update {{flake_path}} # Update specific input # Usage: just upp nixpkgs [group('nix')] upp input: nix flake update {{input}} # Test [group('nix')] ft: nh os test --hostname {{hostname}} {{flake_path}} # Collect Garbage [group('nix')] ncg: nix-collect-garbage --delete-old ; sudo nix-collect-garbage -d ; sudo /run/current-system/bin/switch-to-configuration boot [group('nix')] cleanup: nh clean all To list available commands type, (you must be in the same directory as the justfile): just So just fmt will run nix fmt.\nA lot of the .nu files came from this repo by BlindFS:\nmodern-dot-files he uses Nix Darwin so there are a few changes for NixOS. I found this through this_week_in_nu.\nmy-nu-config\nThe examples use this starship configAylur-dotfiles The logic on the bottom enables starship for Nushell, Zsh, and Bash!\nIf you wan’t to use my config you’ll have to enable the experimental-feature pipe-operators in the same place you enable flakes and nix-command.\nThere are still situations where I need to switch to zsh or bash to get something to work i.e. nix-shell and a few others.\nFrom custom commands to justfile integrations, Nushell offers a wealth of tools to enhance your NixOS experience, even if occasional workarounds are needed. To dive deeper into Nushell and tailor it to your needs, here are some valuable resources to explore, from official documentation to community-driven configurations.\nResources Nushell-Book\nNushell-Cookbook\nnu_scripts some of the custom commands came from here.\nnushell sample-config\nawesome-nu repo\nnu showcase-repo\ndiscord You can find custom commands, configurations, etc here.\n","wordCount":"3160","inLanguage":"en","datePublished":"2025-05-16T19:54:01-04:00","dateModified":"2025-05-16T19:54:01-04:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://tsawyer87.github.io/posts/using_nushell_with_nixos/"},"publisher":{"@type":"Organization","name":"NixOS Blog","logo":{"@type":"ImageObject","url":"https://tsawyer87.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tsawyer87.github.io/ accesskey=h title="NixOS Blog (Alt + H)">NixOS Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
<a href=/index.xml title="RSS Feed"><img src=/rss.png alt="RSS Feed" style=width:24px;height:24px></a></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Using_nushell_with_nixos</h1><div class=post-meta><span title='2025-05-16 19:54:01 -0400 EDT'>May 16, 2025</span></div></header><div class=post-content><h2 id=nushell-and-nixos>Nushell and NixOS<a hidden class=anchor aria-hidden=true href=#nushell-and-nixos>#</a></h2><figure><img loading=lazy src=/images/nu.png alt="nushell logo" width=1000></figure><ul><li><p><strong>TL;DR</strong>:I recently switched default shells from zsh to nushell, this post
is about some of the challenges and advantages of using nushell with NixOS.</p></li><li><p>While the average user might not immediately see significant advantages, those
who frequently work with structured data formats like JSON, YAML, and CSV –
such as developers interacting with APIs, system administrators managing
configurations, and data professionals – will likely find Nushell&rsquo;s native
data handling and powerful pipeline capabilities a plus. Additionally, users
who value a more consistent and safer scripting experience might appreciate
Nushell&rsquo;s language-first design and features like strong typing.</p></li><li><p>I&rsquo;ll start with some of the unique build design choices and unique features
that I think make Nushell special, then show an example using Nushell to
manipulate JSON data. Finally, I will highlight some of the visually appealing
aspects of Nushell and lastly I share some resources for learning more.</p></li></ul><h2 id=the-good>The Good<a hidden class=anchor aria-hidden=true href=#the-good>#</a></h2><ul><li><p>Nushell borrows concepts from many shells and languages and is itself both a
programming language and a shell. Because of this, it has its own way of
working with files, directories, websites, and more.</p></li><li><p>Nushell is powerful and has many essential commands built directly into the
shell (&ldquo;internal&rdquo; commands) rather than a link to an executable. You can use
this set of commands across different operating systems, having this
consistency is helpful when creating cross-platform code.</p></li><li><p>When internal Nushell commands (like <code>ls</code>, <code>open</code>, <code>where</code>, <code>get</code>, <code>sort-by</code>,
etc.) produce output, they generally do so in Nushell&rsquo;s structured data format
(tables or records). This is the shell&rsquo;s native way of representing information.</p></li><li><p>Beyond these foundational strengths, Nushell offers a range of unique features
that enhance its functionality and make it particularly well-suited for
data-heavy tasks. Here are some highlights that showcase its versatility.</p></li></ul><p><strong>Some Unique Features</strong>:</p><ul><li><p>Besides the built-in commands, Nushell has a <a href=https://www.nushell.sh/book/standard_library.html>standard library</a>
Nushell operates on <em>structured data</em>. You could call it a &ldquo;data-first&rdquo; shell
and programming language.</p></li><li><p>Also included, is a full-featured dataframe processing engine using
<a href=https://github.com/pola-rs/polars>Polars</a> if you want to process large data
efficiently directly in your shell, check out the <a href=https://www.nushell.sh/book/dataframes.html>Dataframes-Docs</a></p></li><li><p><strong>Multi-Line Editing</strong>:</p></li><li><p>When writing a long command you can press Enter to add a newline and move to
the next line. For example:</p></li></ul><pre tabindex=0><code class=language-nu data-lang=nu>ls            |    # press enter
where name =~ |    # press enter, comments after pipe ok
get name      |    # press enter
mv ...$in ./backups/
</code></pre><ul><li><p>This allows you to cycle through the entire multi-line command using the up
and down arrow keys and then customize different lines or sections of the command.</p></li><li><p>You can manually insert a newline using <code>Alt+Enter</code> or <code>Shift+Enter</code>.</p></li><li><p>The <a href=https://www.nushell.sh/book/line_editor.html>Reedline-Editor</a> is powerful
and provides good <code>vi-mode</code> or <code>emacs</code> support built in.</p></li><li><p>It&rsquo;s default <code>Ctrl+r</code> history command is nice to work with out of the box.</p></li><li><p>The <a href=https://www.nushell.sh/book/explore.html#parameters>explore</a> command, is
nu&rsquo;s version of a table pager, just like <code>less</code> but for table structured data:</p></li></ul><pre tabindex=0><code class=language-nu data-lang=nu>$nu | explore --peek
</code></pre><ul><li><p>With the above command you can navigate with vim keybinds or arrow keys.</p></li><li><p>These features demonstrate Nushell’s user-friendly interface, but what truly
sets it apart is its underlying design as a structured data scripting language.
This “language-first” approach powers many of its distinctive capabilities.</p></li></ul><figure><img loading=lazy src=/images/explore.png alt="explore command" width=80%></figure><p><strong>Unique design</strong>:</p><ul><li><p><strong>Fundamentally designed as a structured data scripting language</strong>: and then
it acts as a shell on top of that foundation. This &ldquo;language first&rdquo; approach
is what gives it many of its distinctive features and makes it a powerful
scripting language. I reiterate this here because of the implications of this.
A few of those features are:</p><ul><li><p><strong>Pipelines of structured data</strong>: Unlike traditional shells that primarily
deal with plain text streams, Nushell pipelines operate on tables of
structured data. Each command can understand and manipulate this structured
data directly.</p></li><li><p><strong>Consistent syntax</strong>: Its syntax is more consistent and predictable compared
to the often quirky syntax of Bash and Zsh, drawing inspiration from
other programming languages.</p></li><li><p><strong>Strong typing</strong> Nushell has a type system, which helps catch errors early
and allows for more robust scripting.</p></li><li><p><strong>First-class data types</strong>: It treats various data formats (like JSON, CSV,
TOML) as native data types, making it easier to work with them. Because of this,
Nushell aims to replace the need for external tools like <code>jq</code>, <code>awk</code>, <code>sed</code>,
<code>cut</code>, and even some uses of <code>grep</code> and <code>curl</code>.</p></li></ul></li><li><p><strong>Variables are Immutable by Default</strong>: Nushell&rsquo;s commands are based on a
functional-style of programming which requires immutability, sound familiar?</p></li><li><p><strong>Nushell&rsquo;s Environment is Scoped</strong>: Nushell takes many design cues from
compiled languages, one is that languages should avoid global mutable state.
Shells have commonly used global mutation to update the environment, Nushell
attempts to steer clear of this increasing reproducability.</p></li><li><p><strong>Single-use Environment Variables</strong>:</p></li></ul><pre tabindex=0><code class=language-nu data-lang=nu>FOO=BAR $env.FOO
# =&gt; BAR
</code></pre><ul><li><strong>Permanent Environment Variables</strong>: In your <code>config.nu</code></li></ul><pre tabindex=0><code class=language-nu data-lang=nu># config.nu
$env.FOO = &#39;BAR&#39;
</code></pre><ul><li><p><a href=https://www.nushell.sh/book/coming_from_bash.html>Coming-From-Bash</a></p></li><li><p>These design principles make Nushell a powerful tool for scripting, but
they’re best understood through a hands-on example. Let’s see how Nushell’s
structured data capabilities shine in a common task: processing a JSON file.</p></li></ul><p><strong>Example</strong>: I wanted to provide a practical example to illustrate some of these
&ldquo;Good&rdquo; features in action. And break it down for better understanding.</p><ul><li><p>Let&rsquo;s consider a common task: processing data from a JSON file. Imagine you
have a file containing a list of users with their names and ages. With
traditional shells, you&rsquo;d likely need to rely on external tools like <code>jq</code> to
parse and filter this data. However, Nushell can handle this directly within
its own commands.</p></li><li><p>For this example you could create a <code>test</code> directory and move to it:</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mkdir test ; cd test
</span></span></code></pre></div><ul><li>Create a <code>users.json</code> with the following contents:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>[
</span></span><span style=display:flex><span>  { <span style=color:#f92672>&#34;name&#34;</span>: <span style=color:#e6db74>&#34;Alice&#34;</span>, <span style=color:#f92672>&#34;age&#34;</span>: <span style=color:#ae81ff>25</span> },
</span></span><span style=display:flex><span>  { <span style=color:#f92672>&#34;name&#34;</span>: <span style=color:#e6db74>&#34;Bob&#34;</span>, <span style=color:#f92672>&#34;age&#34;</span>: <span style=color:#ae81ff>30</span> },
</span></span><span style=display:flex><span>  { <span style=color:#f92672>&#34;name&#34;</span>: <span style=color:#e6db74>&#34;Charlie&#34;</span>, <span style=color:#f92672>&#34;age&#34;</span>: <span style=color:#ae81ff>20</span> }
</span></span><span style=display:flex><span>]
</span></span></code></pre></div><ul><li>And create the following <code>filter.nu</code> that first converts <code>users.json</code> into
its own internal structured data format with the <code>open</code> command, then to filters
out people under <code>21</code> with the <code>where</code> control flow construct, then selects the
<code>name</code> and <code>age</code> columns, sorts them by age, and finally converts them back to
<code>json</code> and saves them to a file called <code>filtered_users.json</code>. A lot happening
in a 6 line script.</li></ul><pre tabindex=0><code class=language-nu data-lang=nu>open users.json           # Read JSON file into structured data
| where age &gt; 21         # Filter users older than 21
| select name age        # Select only name and age columns
| sort-by age            # Sort by age
| to json                # Convert back to JSON
| save filtered_users.json # Save result to a new file
</code></pre><ul><li>The <code>open</code> command takes data from a file (or even a URL in some cases) and
parses it and converts it into Nushells own internal structured data format.
So this command isn&rsquo;t just showing you the contents of <code>users.json</code> but doing
a conversion to Nu&rsquo;s special structured format.</li></ul><pre tabindex=0><code class=language-nu data-lang=nu>open users.json
╭───┬─────────┬─────╮
│ # │  name   │ age │
├───┼─────────┼─────┤
│ 0 │ Alice   │  25 │
│ 1 │ Bob     │  30 │
│ 2 │ Charlie │  20 │
╰───┴─────────┴─────╯
</code></pre><ul><li>The <code>source</code> command in Nushell is used to execute the commands within a script
file (like <code>filter.nu</code>) in the current Nushell environment. It&rsquo;s similar to
running the script directly in the shell, but keeps the shell open for further
use. In this example, <code>source filter.nu</code> runs the commands inside <code>filter.nu</code>,
processing the <code>users.json</code> file and creating the <code>filtered_users.json</code> file:</li></ul><pre tabindex=0><code class=language-nu data-lang=nu>source filter.nu
bat filtered_users.json
───────┬──────────────────────────────────────────────────────────────────────────────────────
       │ File: filtered_users.json
───────┼──────────────────────────────────────────────────────────────────────────────────────
   1   │ [
   2   │   {
   3   │     &#34;name&#34;: &#34;Alice&#34;,
   4   │     &#34;age&#34;: 25
   5   │   },
   6   │   {
   7   │     &#34;name&#34;: &#34;Bob&#34;,
   8   │     &#34;age&#34;: 30
   9   │   }
  10   │ ]
───────┴───────────────────────────────────────────────────────────────────────────────────
</code></pre><ul><li>As you can see, without needing any external tools, Nushell was able to read,
filter, select, sort, and then re-serialize JSON data using a clear and concise
pipeline. This demonstrates its power in handling structured data natively,
making common data manipulation tasks within the shell significantly more
streamlined and readable compared to traditional approaches.</li></ul><p><strong>In the filter.nu example:</strong></p><pre tabindex=0><code class=language-nu data-lang=nu>open users.json           # Read JSON file into structured data
| where age &gt; 21         # Filter users older than 21
| select name age        # Select only name and age columns
| sort-by age            # Sort by age
| to json                # Convert back to JSON
| save filtered_users.json # Save result to a new file
</code></pre><ol><li><p><code>open users.json</code>: Produces a <strong>Nushell table</strong> representing the data.</p></li><li><p><code>| where age > 21</code>: Receives the table, filters rows based on the <code>age</code>
column, and outputs a new, filtered table.</p></li><li><p><code>| select name age</code>: Receives the filtered table, selects only the <code>name</code> and
<code>age</code> columns, and outputs a table with fewer columns.</p></li><li><p><code>| sort-by age</code>: Receives the table, sorts the rows based on the <code>age</code> column,
and outputs a sorted table.</p></li><li><p><code>| to json</code>: Receives the sorted table and converts it back into JSON text.</p></li><li><p><code>| save filtered_users.json</code>: Receives the JSON text and saves it to a file.</p></li></ol><ul><li><p>So, while the concept of piping is the same, the nature of the data flowing
through the Nushell pipeline is richer and more structured, enabling more
powerful and direct data manipulation.</p></li><li><p>While Nushell’s strengths, like its structured data pipelines, make it a
game-changer for many tasks, it’s not without its challenges, especially when
integrated with NixOS’s Bash-centric ecosystem. Let’s explore some of the
limitations you might encounter when adopting Nushell as your default shell.</p></li></ul><h2 id=the-bad>The Bad<a hidden class=anchor aria-hidden=true href=#the-bad>#</a></h2><ul><li><p>While the project is still maturing, the active community and ongoing
improvements are promising. Don&rsquo;t get too discouraged by the following, there
would be a bad section for any shell imo.</p></li><li><p>There are many similarities so it can be easy to forget that some Bash (and
POSIX in general) style constructs just won&rsquo;t work in Nushell. Considering
that NixOS seems to have been designed for bash, even Zsh isn&rsquo;t fully
compatable you may want to think twice before you choose Nushell as your
default.</p></li><li><p>The documentation is incomplete and written by devs for devs imo, it is quite
a bit different from anything else I&rsquo;ve seen so there is a bit of a learning
curve. Nushell is generally still considered to be in a stage where it might
not be the most seamless or trouble-free experience as a daily driver default
shell for most users, especially on a system like NixOS known for its unique
approach.</p></li><li><p>The <a href=https://github.com/haslersn/any-nix-shell>any-nix-shell</a> project doesn&rsquo;t
include Nushell as with many others because of it&rsquo;s lack of maturity.</p></li><li><p>The following addition comes from Joey_McKur&rsquo;s sugggestion, on mentioning the
<code>job</code> command as one of the biggest criticisms against Nu because it doesn&rsquo;t
support background tasks. I should also note that Nushell&rsquo;s team is aware of
these criticisms and actively working on improving job control.</p></li></ul><p><strong>Limited Feature Set Compared to Traditional Job Control:</strong></p><ul><li><p><strong>Lack of Full POSIX Job Control</strong>: Nushell&rsquo;s job control doesn&rsquo;t yet fully
implement all the features and signals defined by POSIX job control (e.g., more
nuanced signal handling, stopped jobs). While it covers the basics, users
accustomed to advanced Bash job control might find it lacking.</p></li><li><p><strong>Foregrounding Behavior</strong>: There have been criticisms about how foregrounding
jobs interacts with the terminal and potential issues with signal propagation.</p></li></ul><p><strong>Output Handling Challenges</strong>:</p><ul><li><p><strong>Interleaved Output</strong>: Managing the output of multiple backgrounded jobs can
sometimes be messy, with output from different jobs potentially interleaving in
the terminal. While Nushell tries to handle this, it&rsquo;s not always as clean as
desired.</p></li><li><p><strong>Redirection Complexity</strong>: Redirecting the input and output of backgrounded
jobs can be less straightforward than in Bash, sometimes requiring more
explicit handling.</p></li></ul><p><strong>Integration with Pipelines:</strong></p><ul><li><strong>Backgrounding Pipelines</strong>: Backgrounding complex pipelines with multiple
stages can sometimes lead to unexpected behavior or difficulties in managing
the entire pipeline as a single job.</li></ul><p><strong>Error Reporting:</strong></p><ul><li><p><strong>Difficult to Track Errors in Background Jobs</strong>: Identifying and debugging
errors in backgrounded jobs can be less direct than with foreground processes,
and the job command&rsquo;s output might not always provide sufficient information
for troubleshooting.</p></li><li><p>Many of Nushell’s challenges stem from its departure from traditional shell
conventions, particularly those of Bash, which NixOS heavily relies on. To
better understand these differences and how they impact your workflow, let’s
compare Nushell’s static, structured approach to Bash’s dynamic, text-based
model.</p></li></ul><h2 id=key-differences-between-nushell--bash>Key Differences Between Nushell & Bash<a hidden class=anchor aria-hidden=true href=#key-differences-between-nushell--bash>#</a></h2><table><thead><tr><th><strong>Feature</strong></th><th><strong>Bash (Dynamic)</strong></th><th><strong>Nushell (Static)</strong></th></tr></thead><tbody><tr><td>Code Execution</td><td>Line-by-line</td><td>Whole script parsed first</td></tr><tr><td>Error Detection</td><td>Runtime errors only</td><td>Catches errors before running</td></tr><tr><td>Support for <code>eval</code></td><td>✅ Allowed</td><td>❌ Not supported</td></tr><tr><td>Custom Parsing</td><td>Limited</td><td>Built-in semantic analysis</td></tr><tr><td>IDE Features</td><td>Basic syntax highlighting</td><td>Advanced integration, linting, and formatting</td></tr></tbody></table><ul><li><p><code>&&</code> doesn&rsquo;t work use <code>;</code> instead.</p></li><li><p><code>></code> is used as the greater-than operator for comparisons:</p></li></ul><pre tabindex=0><code class=language-nu data-lang=nu>&#34;hello&#34; | save output.txt
</code></pre><p>is equivalent to the following in bash:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>echo <span style=color:#e6db74>&#34;hello&#34;</span> &gt; output.txt
</span></span></code></pre></div><ul><li>If you notice above the nushell command doesn&rsquo;t require an <code>echo</code> prefix, this
is because Nushell has <strong>Implicit Return</strong>:</li></ul><pre tabindex=0><code class=language-nu data-lang=nu>&#34;Hello, World&#34; == (echo &#34;Hello, World&#34;)
# =&gt; true
</code></pre><ul><li><p>The above example shows that the string, <code>"Hello, World"</code> is equivalent to the
output value from <code>echo "Hello, World"</code></p></li><li><p><strong>Every Command Returns a Value</strong>:</p></li></ul><pre tabindex=0><code class=language-nu data-lang=nu>let p = 7
print $p  # 7
$p * 6    # 42
</code></pre><ul><li>Understanding these differences highlights why Nushell feels so distinct from
Bash, but it’s the shell’s advanced features and integrations that truly make
it shine. Let’s dive into some of the beautiful and powerful tools and custom
commands that elevate Nushell for NixOS users.</li></ul><h2 id=the-beautiful-and-powerful>The Beautiful and Powerful<a hidden class=anchor aria-hidden=true href=#the-beautiful-and-powerful>#</a></h2><ul><li><p><code>Ctrl+t</code> List Commands with carapace and fzf:</p><figure><img loading=lazy src=/images/nu4.png alt=atuin width=80%></figure></li><li><p><code>Carapace</code> <a href=https://carapace-sh.github.io/carapace-bin/install.html>Carapace-Bin Install</a>:</p><figure><img loading=lazy src=/images/nu9.png alt=carapace width=1000></figure></li><li><p><code>Carapace</code> man example:</p><figure><img loading=lazy src=/images/nu7.png alt=carapace_man width=80%></figure></li></ul><p><strong>Custom Nushell Commands</strong></p><ul><li>The following command allows you to choose which input to update interactively
with fzf.</li></ul><pre tabindex=0><code class=language-nu data-lang=nu># nix.nu
# upgrade system packages
# `nix-upgrade` or `nix-upgrade -i`
def nix-upgrade [
  flake_path: string = &#34;/home/jr/flake&#34;, # path that contains a flake.nix
  --interactive (-i) # select packages to upgrade interactively
]: nothing -&gt; nothing {
  let working_path = $flake_path | path expand
  if not ($working_path | path exists) {
    echo &#34;path does not exist: $working_path&#34;
    exit 1
  }
  let pwd = $env.PWD
  cd $working_path
  if $interactive {
    let selections = nix flake metadata . --json
    | from json
    | get locks.nodes
    | columns
    | str join &#34;\n&#34;
    | fzf --multi --tmux center,20%
    | lines
    # Debug: Print selections to verify
    print $&#34;Selections: ($selections)&#34;
    # Check if selections is empty
    if ($selections | is-empty) {
      print &#34;No selections made.&#34;
      cd $pwd
      return
    }
    # Use spread operator to pass list items as separate arguments
    nix flake update ...$selections
  } else {
    nix flake update
  }
  cd $pwd
  nh os switch $working_path
}
</code></pre><figure><img loading=lazy src=/images/nu5.png alt=carapace width=80%></figure><ul><li>The <code>ns</code> command is designed to search for Nix packages using <code>nix search</code> and
present the results in a cleaner format, specifically removing the architecture
and operating system prefix that nix search often includes.</li></ul><pre tabindex=0><code class=language-nu data-lang=nu>def ns [
    term: string # Search target.
] {

    let info = (
        sysctl -n kernel.arch kernel.ostype
        | lines
        | {arch: ($in.0|str downcase), ostype: ($in.1|str downcase)}
    )

    nix search --json nixpkgs $term
        | from json
        | transpose package description
        | flatten
        | select package description version
        | update package {|row| $row.package | str replace $&#34;legacyPackages.($info.arch)-($info.ostype).&#34; &#34;&#34;}
}
</code></pre><figure><img loading=lazy src=/images/nu10.png alt="nix search" width=80%></figure><ul><li><code>nufetch</code> command:</li></ul><pre tabindex=0><code class=language-nu data-lang=nu># `nufetch` `(nufetch).packages`
def nufetch [] {
{
&#34;kernel&#34;: $nu.os-info.kernel_version,
&#34;nu&#34;: $env.NU_VERSION,
&#34;packages&#34;: (ls /etc/profiles/per-user | select name | prepend [[name];
[&#34;/run/current-system/sw&#34;]] | each { insert &#34;number&#34; (nix path-info --recursive
 ($in | get name) | lines | length) | insert &#34;size&#34; ( nix path-info -S
 ($in | get name) | parse -r &#39;\s(.*)&#39; | get capture0.0 | into filesize) | update
 &#34;name&#34; ($in | get name | parse -r &#39;.*/(.*)&#39; | get capture0.0 | if $in == &#34;sw&#34;
 {&#34;system&#34;} else {$in}) | rename &#34;environment&#34;}),
&#34;uptime&#34;: (sys host).uptime
}
}
</code></pre><figure><img loading=lazy src=/images/nu1.png alt=nufetch width=80%></figure><ul><li><code>duf</code> command, I have mine aliased to <code>df</code>:</li></ul><figure><img loading=lazy src=/images/nu8.png alt=duff width=80%></figure><ul><li><code>ps</code> command:</li></ul><figure><img loading=lazy src=/images/ps.png alt=ps width=80%></figure><ul><li>Adding the following to your <code>configuration.nix</code> will show you the diff of the
closures on rebuild:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span><span style=color:#75715e># configuration.nix</span>
</span></span><span style=display:flex><span><span style=color:#75715e># During system activation, compare the closure size difference between the</span>
</span></span><span style=display:flex><span><span style=color:#75715e># current and new system and display a formatted table if significant changes are</span>
</span></span><span style=display:flex><span><span style=color:#75715e># detected.</span>
</span></span><span style=display:flex><span>system<span style=color:#f92672>.</span>activationScripts<span style=color:#f92672>.</span>diff <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  if [[ -e /run/current-system ]]; then
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    </span><span style=color:#e6db74>${</span>pkgs<span style=color:#f92672>.</span>nushell<span style=color:#e6db74>}</span><span style=color:#e6db74>/bin/nu -c &#34;let diff_closure = (</span><span style=color:#e6db74>${</span>pkgs<span style=color:#f92672>.</span>nix<span style=color:#e6db74>}</span><span style=color:#e6db74>/bin/nix store
</span></span></span><span style=display:flex><span><span style=color:#e6db74>     diff-closures /run/current-system &#39;$systemConfig&#39;); let table =
</span></span></span><span style=display:flex><span><span style=color:#e6db74>     (\$diff_closure | lines | where \$it =~ KiB | where \$it =~ → | parse -r
</span></span></span><span style=display:flex><span><span style=color:#e6db74>     &#39;^(?&lt;Package&gt;\S+): (?&lt;Old&gt;[^,]+)(?:.*) → (?&lt;New&gt;[^,]+)(?:.*), (?&lt;DiffBin&gt;.*)$&#39;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>     | insert Diff { get DiffBin | ansi strip | into filesize } | sort-by -r Diff
</span></span></span><span style=display:flex><span><span style=color:#e6db74>     | reject DiffBin); if (\$table | get Diff | is-not-empty) { print \&#34;\&#34;; \$table
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    | append [[Package Old New Diff]; [\&#34;\&#34; \&#34;\&#34; \&#34;\&#34; \&#34;\&#34;]] | append [[Package Old
</span></span></span><span style=display:flex><span><span style=color:#e6db74>     New Diff]; [\&#34;\&#34; \&#34;\&#34; \&#34;Total:\&#34; (\$table | get Diff | math sum) ]]
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    | print; print \&#34;\&#34; }&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  fi
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#39;&#39;</span>;
</span></span></code></pre></div><figure><img loading=lazy src=/images/config1.png alt=Diff width=80%></figure><ul><li><code>nix-list-system</code> command lists all installed packages:</li></ul><pre tabindex=0><code class=language-nu data-lang=nu># list all installed packages
def nix-list-system []: nothing -&gt; list&lt;string&gt; {
  ^nix-store -q --references /run/current-system/sw
  | lines
  | filter { not ($in | str ends-with &#39;man&#39;) }
  | each { $in | str replace -r &#39;^[^-]*-&#39; &#39;&#39; }
  | sort
}
</code></pre><figure><img loading=lazy src=/images/nu6.png alt=obsidian width=80%></figure><ul><li>These custom Nushell commands showcase its flexibility, but sometimes you need
to work around Nushell’s limitations, like compatability with certain NixOS
tools. This is where <code>just</code> and <code>justfiles</code> come in, simplifying complex
workflows and bridging gaps in Nushell’s functionality.</li></ul><h3 id=using-just-and-justfiles>Using Just and Justfiles<a hidden class=anchor aria-hidden=true href=#using-just-and-justfiles>#</a></h3><ul><li><p>The following is my <code>justfile</code> that I keep right next to my <code>flake.nix</code> it
simplifies some commands and makes things work that weren&rsquo;t working with
nushell for my case, you&rsquo;ll have to change it to match your configuration.
It&rsquo;s not perfect but works for my use case, take whats useful and leave the
rest.</p></li><li><p>You&rsquo;ll first need to install <a href=https://github.com/casey/just>just</a>
to make use of <code>justfiles</code>.</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># nix shell nixpkgs#just nixpkgs#nushell</span>
</span></span><span style=display:flex><span>set shell :<span style=color:#f92672>=</span> <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;nu&#34;</span>, <span style=color:#e6db74>&#34;-c&#34;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>flake_path :<span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;/home/jr/flake&#34;</span>
</span></span><span style=display:flex><span>hostname :<span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;magic&#34;</span>
</span></span><span style=display:flex><span>home_manager_output :<span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;jr@magic&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>utils_nu :<span style=color:#f92672>=</span> absolute_path<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;utils.nu&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>default:
</span></span><span style=display:flex><span>    @just --list
</span></span><span style=display:flex><span><span style=color:#75715e># Rebuild</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>group<span style=color:#f92672>(</span><span style=color:#e6db74>&#39;nix&#39;</span><span style=color:#f92672>)]</span>
</span></span><span style=display:flex><span>fr:
</span></span><span style=display:flex><span>    nh os switch --hostname <span style=color:#f92672>{{</span>hostname<span style=color:#f92672>}}</span> <span style=color:#f92672>{{</span>flake_path<span style=color:#f92672>}}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Flake Update</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>group<span style=color:#f92672>(</span><span style=color:#e6db74>&#39;nix&#39;</span><span style=color:#f92672>)]</span>
</span></span><span style=display:flex><span>fu:
</span></span><span style=display:flex><span>    nh os switch  --hostname <span style=color:#f92672>{{</span>hostname<span style=color:#f92672>}}</span> --update <span style=color:#f92672>{{</span>flake_path<span style=color:#f92672>}}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Update specific input</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Usage: just upp nixpkgs</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>group<span style=color:#f92672>(</span><span style=color:#e6db74>&#39;nix&#39;</span><span style=color:#f92672>)]</span>
</span></span><span style=display:flex><span>upp input:
</span></span><span style=display:flex><span>    nix flake update <span style=color:#f92672>{{</span>input<span style=color:#f92672>}}</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Test</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>group<span style=color:#f92672>(</span><span style=color:#e6db74>&#39;nix&#39;</span><span style=color:#f92672>)]</span>
</span></span><span style=display:flex><span>ft:
</span></span><span style=display:flex><span>    nh os test --hostname <span style=color:#f92672>{{</span>hostname<span style=color:#f92672>}}</span> <span style=color:#f92672>{{</span>flake_path<span style=color:#f92672>}}</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Collect Garbage</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>group<span style=color:#f92672>(</span><span style=color:#e6db74>&#39;nix&#39;</span><span style=color:#f92672>)]</span>
</span></span><span style=display:flex><span>ncg:
</span></span><span style=display:flex><span>    nix-collect-garbage --delete-old ; sudo nix-collect-garbage -d ; sudo /run/current-system/bin/switch-to-configuration boot
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>group<span style=color:#f92672>(</span><span style=color:#e6db74>&#39;nix&#39;</span><span style=color:#f92672>)]</span>
</span></span><span style=display:flex><span>cleanup:
</span></span><span style=display:flex><span>    nh clean all
</span></span></code></pre></div><ul><li>To list available commands type, (you must be in the same directory as the
justfile): <code>just</code></li></ul><figure><img loading=lazy src=/images/just2.png alt=just width=80%></figure><ul><li><p>So <code>just fmt</code> will run <code>nix fmt</code>.</p></li><li><p>A lot of the <code>.nu</code> files came from this repo by BlindFS:</p><ul><li><p><a href=https://github.com/blindFS/modern-dot-files/tree/main>modern-dot-files</a>
he uses Nix Darwin so there are a few changes for NixOS. I found this
through <a href=https://github.com/nushell/this_week_in_nu>this_week_in_nu</a>.</p></li><li><p><a href=https://github.com/saylesss88/flake/tree/main/home/shells/nushell>my-nu-config</a></p></li><li><p>The examples use this starship config<a href=https://github.com/Aylur/dotfiles/blob/main/home/starship.nix>Aylur-dotfiles</a>
The logic on the bottom enables starship for Nushell, Zsh, and Bash!</p></li><li><p>If you wan&rsquo;t to use my config you&rsquo;ll have to enable the experimental-feature
<code>pipe-operators</code> in the same place you enable flakes and nix-command.</p></li></ul></li><li><p>There are still situations where I need to switch to zsh or bash to get something
to work i.e. <code>nix-shell</code> and a few others.</p></li><li><p>From custom commands to <code>justfile</code> integrations, Nushell offers a wealth of
tools to enhance your NixOS experience, even if occasional workarounds are
needed. To dive deeper into Nushell and tailor it to your needs, here are some
valuable resources to explore, from official documentation to community-driven
configurations.</p></li></ul><h3 id=resources>Resources<a hidden class=anchor aria-hidden=true href=#resources>#</a></h3><ul><li><p><a href=https://www.nushell.sh/book/>Nushell-Book</a></p></li><li><p><a href=https://www.nushell.sh/cookbook/>Nushell-Cookbook</a></p></li><li><p><a href=https://github.com/nushell/nu_scripts>nu_scripts</a> some of the custom
commands came from here.</p></li><li><p><a href=https://github.com/nushell/nushell/tree/main/crates/nu-utils/src/default_files>nushell sample-config</a></p></li><li><p><a href=https://github.com/nushell/awesome-nu#plugins>awesome-nu repo</a></p></li><li><p><a href=https://github.com/nushell/showcase>nu showcase-repo</a></p></li><li><p><a href=https://discord.com/invite/NtAbbGn>discord</a> You can find custom commands,
configurations, etc here.</p></li></ul></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://tsawyer87.github.io/>NixOS Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>