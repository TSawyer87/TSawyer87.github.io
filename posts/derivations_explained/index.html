<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Derivations_explained | NixOS Blog</title><meta name=keywords content><meta name=description content="Introduction to Nix Derivations

     




A derivation in Nix is a fundamental concept that describes how to build a piece of software or a resource (e.g., a package, library, or configuration file). Think of it as a recipe for creating something within the Nix ecosystem.


For beginners, the analogy of a cooking recipe is helpful:

Ingredients (Dependencies): What other software or libraries are needed.
Steps (Build Instructions): The commands to compile, configure, and install.
Final Dish (Output): The resulting package or resource.



A Nix derivation encapsulates all this information, telling Nix what inputs
to use, how to build it, and what the final output should be."><meta name=author content="T Sawyer"><link rel=canonical href=https://tsawyer87.github.io/posts/derivations_explained/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://tsawyer87.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://tsawyer87.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://tsawyer87.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://tsawyer87.github.io/apple-touch-icon.png><link rel=mask-icon href=https://tsawyer87.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://tsawyer87.github.io/posts/derivations_explained/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://tsawyer87.github.io/posts/derivations_explained/"><meta property="og:site_name" content="NixOS Blog"><meta property="og:title" content="Derivations_explained"><meta property="og:description" content="Introduction to Nix Derivations A derivation in Nix is a fundamental concept that describes how to build a piece of software or a resource (e.g., a package, library, or configuration file). Think of it as a recipe for creating something within the Nix ecosystem.
For beginners, the analogy of a cooking recipe is helpful:
Ingredients (Dependencies): What other software or libraries are needed. Steps (Build Instructions): The commands to compile, configure, and install. Final Dish (Output): The resulting package or resource. A Nix derivation encapsulates all this information, telling Nix what inputs to use, how to build it, and what the final output should be."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-14T19:25:48-04:00"><meta property="article:modified_time" content="2025-05-14T19:25:48-04:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Derivations_explained"><meta name=twitter:description content="Introduction to Nix Derivations

     




A derivation in Nix is a fundamental concept that describes how to build a piece of software or a resource (e.g., a package, library, or configuration file). Think of it as a recipe for creating something within the Nix ecosystem.


For beginners, the analogy of a cooking recipe is helpful:

Ingredients (Dependencies): What other software or libraries are needed.
Steps (Build Instructions): The commands to compile, configure, and install.
Final Dish (Output): The resulting package or resource.



A Nix derivation encapsulates all this information, telling Nix what inputs
to use, how to build it, and what the final output should be."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tsawyer87.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Derivations_explained","item":"https://tsawyer87.github.io/posts/derivations_explained/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Derivations_explained","name":"Derivations_explained","description":"Introduction to Nix Derivations A derivation in Nix is a fundamental concept that describes how to build a piece of software or a resource (e.g., a package, library, or configuration file). Think of it as a recipe for creating something within the Nix ecosystem.\nFor beginners, the analogy of a cooking recipe is helpful:\nIngredients (Dependencies): What other software or libraries are needed. Steps (Build Instructions): The commands to compile, configure, and install. Final Dish (Output): The resulting package or resource. A Nix derivation encapsulates all this information, telling Nix what inputs to use, how to build it, and what the final output should be.\n","keywords":[],"articleBody":"Introduction to Nix Derivations A derivation in Nix is a fundamental concept that describes how to build a piece of software or a resource (e.g., a package, library, or configuration file). Think of it as a recipe for creating something within the Nix ecosystem.\nFor beginners, the analogy of a cooking recipe is helpful:\nIngredients (Dependencies): What other software or libraries are needed. Steps (Build Instructions): The commands to compile, configure, and install. Final Dish (Output): The resulting package or resource. A Nix derivation encapsulates all this information, telling Nix what inputs to use, how to build it, and what the final output should be.\nCreating Derivations in Nix The primary way to define packages in Nix is through the mkDerivation function, which is part of the standard environment (stdenv). While a lower-level derivation function exists for advanced use cases, mkDerivation simplifies the process by automatically managing dependencies and the build environment.\nmkDerivation (and derivation) takes a set of attributes as its argument. At a minimum, you’ll often encounter these essential attributes:\nname: A human-readable identifier for the derivation (e.g., “foo”, “hello.txt”). This helps you and Nix refer to the package. system: Specifies the target architecture for the build (e.g., builtins.currentSystem for your current machine). builder: Defines the program that will execute the build instructions (e.g., bash). Our First Simple Derivation: Understanding the Builder To understand how derivations work, let’s create a very basic example using a bash script as our builder. Why a Builder Script? The builder attribute in a derivation tells Nix how to perform the build steps. A simple and common way to define these steps is with a bash script. The Challenge with Shebangs in Nix In typical Unix-like systems, you might start a bash script with a shebang (#!/bin/bash or #!/usr/bin/env bash) to tell the system how to execute it. However, in Nix derivations, we generally avoid this.\nReason: Nix builds happen in an isolated environment where the exact path to common tools like bash isn’t known beforehand (it resides within the Nix store). Hardcoding a path or relying on the system’s PATH would break Nix’s stateless property.\nThe Importance of Statelessness in Nix Stateful Systems (Traditional): When you install software traditionally, it often modifies the core system environment directly. This can lead to dependency conflicts and makes rollbacks difficult.\nStateless Systems (Nix): Nix takes a different approach. When installing a package, it creates a unique, immutable directory in the Nix store. This means:\nNo Conflicts: Different versions of the same package can coexist without interfering with each other. Reliable Rollback: You can easily switch back to previous versions without affecting system-wide files. Reproducibility: Builds are more likely to produce the same result across different machines if they are “pure” (don’t rely on external system state). Our builder Script For our first derivation, we’ll create a simple builder.sh file in the current directory: # builder.sh declare -xp echo foo \u003e $out The command declare -xp lists exported variables (it’s a bash builtin function).\nNix needs to know where the final built product (the “cake” in our earlier analogy) should be placed. So, during the derivation process, Nix calculates a unique output path within the Nix store. This path is then made available to our builder script as an environment variable named $out. The .drv file, which is the recipe, contains instructions for the builder, including setting up this $out variable. Our builder script will then put the result of its work (in this case, the “foo” file) into this specific $out directory.\nAs mentioned earlier we need to find the nix store path to the bash executable, common way to do this is to load Nixpkgs into the repl and check:\nnix-repl\u003e :l Added 3950 variables. nix-repl\u003e \"${bash}\" \"/nix/store/ihmkc7z2wqk3bbipfnlh0yjrlfkkgnv6-bash-4.2-p45\" So, with this little trick we are able to refer to bin/bash and create our derivation:\nnix-repl\u003e d = derivation { name = \"foo\"; builder = \"${bash}/bin/bash\"; args = [ ./builder.sh ]; system = builtins.currentSystem; } nix-repl\u003e :b d [1 built, 0.0 MiB DL] this derivation produced the following outputs: out -\u003e /nix/store/gczb4qrag22harvv693wwnflqy7lx5pb-foo Boom! The contents of /nix/store/w024zci0x1hh1wj6gjq0jagkc1sgrf5r-foo is really foo! We’ve built our first derivation.\nDerivations are the primitive that Nix uses to define packages. “Package” is a loosely defined term, but a derivation is simply the result of calling builtins.derivation.\nOur Second Derivation The following is a simple hello-drv derivation:\nnix-repl\u003e hello-drv = nixpkgs.stdenv.mkDerivation { name = \"hello.txt\"; unpackPhase = \"true\"; installPhase = '' echo -n \"Hello World!\" \u003e $out ''; } nix-repl\u003e hello-drv «derivation /nix/store/ad6c51ia15p9arjmvvqkn9fys9sf1kdw-hello.txt.drv» Derivations have a .drv suffix, as you can see the result of calling hello-drv is the nix store path to a derivation. Links To Articles about Derivations NixPillsOurFirstDerivation\nNixPills-WorkingDerivation\nnix.dev-Derivations\nnix.dev-packagingExistingSoftware\nhowToLearnNix-MyFirstDerivation\nhowToLearnNix-DerivationsInDetail\nSparky/blog-creatingASuperSimpleDerivation # How to learn Nix\nSparky/blog-Derivations102\nScriveNixWorkshop-nixDerivationBasics\nzeroToNix-Derivations\nTweag-derivationOutputs\ntheNixLectures-Derivations\nbmcgee-whatAreFixed-OutputDerivations\n","wordCount":"798","inLanguage":"en","datePublished":"2025-05-14T19:25:48-04:00","dateModified":"2025-05-14T19:25:48-04:00","author":{"@type":"Person","name":"T Sawyer"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://tsawyer87.github.io/posts/derivations_explained/"},"publisher":{"@type":"Organization","name":"NixOS Blog","logo":{"@type":"ImageObject","url":"https://tsawyer87.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tsawyer87.github.io/ accesskey=h title="NixOS Blog (Alt + H)">NixOS Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Derivations_explained</h1><div class=post-meta><span title='2025-05-14 19:25:48 -0400 EDT'>May 14, 2025</span>&nbsp;·&nbsp;T Sawyer</div></header><div class=post-content><h1 id=introduction-to-nix-derivations>Introduction to Nix Derivations<a hidden class=anchor aria-hidden=true href=#introduction-to-nix-derivations>#</a></h1><figure><img loading=lazy src=/images/gruv10.png alt=gruv10 width=1000></figure><ul><li><p>A derivation in Nix is a fundamental concept that describes how to build a piece of software or a resource (e.g., a package, library, or configuration file). Think of it as a recipe for creating something within the Nix ecosystem.</p></li><li><p>For beginners, the analogy of a cooking recipe is helpful:</p><ul><li><strong>Ingredients (Dependencies):</strong> What other software or libraries are needed.</li><li><strong>Steps (Build Instructions):</strong> The commands to compile, configure, and install.</li><li><strong>Final Dish (Output):</strong> The resulting package or resource.</li></ul></li><li><p>A Nix derivation encapsulates all this information, telling Nix what inputs
to use, how to build it, and what the final output should be.</p></li></ul><h2 id=creating-derivations-in-nix>Creating Derivations in Nix<a hidden class=anchor aria-hidden=true href=#creating-derivations-in-nix>#</a></h2><ul><li><p>The primary way to define packages in Nix is through the <code>mkDerivation</code> function, which is part of the standard environment (<code>stdenv</code>). While a
lower-level <code>derivation</code> function exists for advanced use cases,
<code>mkDerivation</code> simplifies the process by automatically managing dependencies
and the build environment.</p></li><li><p><code>mkDerivation</code> (and <code>derivation</code>) takes a set of attributes as its argument.
At a minimum, you&rsquo;ll often encounter these essential attributes:</p><ol><li><strong>name:</strong> A human-readable identifier for the derivation
(e.g., &ldquo;foo&rdquo;, &ldquo;hello.txt&rdquo;). This helps you and Nix refer to the package.</li><li><strong>system:</strong> Specifies the target architecture for the build
(e.g., <code>builtins.currentSystem</code> for your current machine).</li><li><strong>builder:</strong> Defines the program that will execute the build instructions
(e.g., <code>bash</code>).</li></ol></li></ul><h2 id=our-first-simple-derivation-understanding-the-builder>Our First Simple Derivation: Understanding the Builder<a hidden class=anchor aria-hidden=true href=#our-first-simple-derivation-understanding-the-builder>#</a></h2><ul><li>To understand how derivations work, let&rsquo;s create a very basic example using a
bash script as our <code>builder</code>.</li></ul><h3 id=why-a-builder-script>Why a Builder Script?<a hidden class=anchor aria-hidden=true href=#why-a-builder-script>#</a></h3><ul><li>The <code>builder</code> attribute in a derivation tells Nix <em>how</em> to perform the build
steps. A simple and common way to define these steps is with a bash script.</li></ul><h3 id=the-challenge-with-shebangs-in-nix>The Challenge with Shebangs in Nix<a hidden class=anchor aria-hidden=true href=#the-challenge-with-shebangs-in-nix>#</a></h3><ul><li><p>In typical Unix-like systems, you might start a bash script with a shebang
(<code>#!/bin/bash</code> or <code>#!/usr/bin/env bash</code>) to tell the system how to execute it.
However, in Nix derivations, we generally avoid this.</p></li><li><p><strong>Reason:</strong> Nix builds happen in an isolated environment where the exact path
to common tools like <code>bash</code> isn&rsquo;t known beforehand (it resides within the Nix
store). Hardcoding a path or relying on the system&rsquo;s <code>PATH</code> would break Nix&rsquo;s
stateless property.</p></li></ul><h3 id=the-importance-of-statelessness-in-nix>The Importance of Statelessness in Nix<a hidden class=anchor aria-hidden=true href=#the-importance-of-statelessness-in-nix>#</a></h3><ul><li><p><strong>Stateful Systems (Traditional):</strong> When you install software traditionally,
it often modifies the core system environment directly. This can lead to
dependency conflicts and makes rollbacks difficult.</p></li><li><p><strong>Stateless Systems (Nix):</strong> Nix takes a different approach. When installing
a package, it creates a unique, immutable directory in the Nix store. This
means:</p><ul><li><strong>No Conflicts:</strong> Different versions of the same package can coexist
without interfering with each other.</li><li><strong>Reliable Rollback:</strong> You can easily switch back to previous versions
without affecting system-wide files.</li><li><strong>Reproducibility:</strong> Builds are more likely to produce the same result
across different machines if they are &ldquo;pure&rdquo; (don&rsquo;t rely on external
system state).</li></ul></li></ul><h4 id=our-builder-script>Our builder Script<a hidden class=anchor aria-hidden=true href=#our-builder-script>#</a></h4><ul><li>For our first derivation, we&rsquo;ll create a simple <code>builder.sh</code> file in the current directory:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># builder.sh</span>
</span></span><span style=display:flex><span>declare -xp
</span></span><span style=display:flex><span>echo foo &gt; $out
</span></span></code></pre></div><ul><li><p>The command <code>declare -xp</code> lists exported variables (it&rsquo;s a bash builtin
function).</p></li><li><p>Nix needs to know where the final built product (the &ldquo;cake&rdquo; in our earlier
analogy) should be placed. So, during the derivation process, Nix calculates
a unique output path within the Nix store. This path is then made available
to our builder script as an environment variable named <code>$out</code>. The <code>.drv</code>
file, which is the recipe, contains instructions for the builder, including
setting up this <code>$out</code> variable. Our builder script will then put the result
of its work (in this case, the &ldquo;foo&rdquo; file) into this specific <code>$out</code> directory.</p></li><li><p>As mentioned earlier we need to find the nix store path to the bash
executable, common way to do this is to load Nixpkgs into the repl
and check:</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>nix-repl&gt; :l &lt;nixpkgs&gt;
</span></span><span style=display:flex><span>Added <span style=color:#ae81ff>3950</span> variables.
</span></span><span style=display:flex><span>nix-repl&gt; <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>bash<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;/nix/store/ihmkc7z2wqk3bbipfnlh0yjrlfkkgnv6-bash-4.2-p45&#34;</span>
</span></span></code></pre></div><p>So, with this little trick we are able to refer to <code>bin/bash</code> and create
our derivation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>nix-repl&gt; d <span style=color:#f92672>=</span> derivation <span style=color:#f92672>{</span> name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;foo&#34;</span>; builder <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>bash<span style=color:#e6db74>}</span><span style=color:#e6db74>/bin/bash&#34;</span>;
</span></span><span style=display:flex><span> args <span style=color:#f92672>=</span> <span style=color:#f92672>[</span> ./builder.sh <span style=color:#f92672>]</span>; system <span style=color:#f92672>=</span> builtins.currentSystem; <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>nix-repl&gt; :b d
</span></span><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#ae81ff>1</span> built, 0.0 MiB DL<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>this derivation produced the following outputs:
</span></span><span style=display:flex><span>  out -&gt; /nix/store/gczb4qrag22harvv693wwnflqy7lx5pb-foo
</span></span></code></pre></div><ul><li><p>Boom! The contents of <code>/nix/store/w024zci0x1hh1wj6gjq0jagkc1sgrf5r-foo</code>
is really foo! We&rsquo;ve built our first derivation.</p></li><li><p>Derivations are the primitive that Nix uses to define packages. “Package”
is a loosely defined term, but a derivation is simply the result of calling
<code>builtins.derivation</code>.</p></li></ul><h4 id=our-second-derivation>Our Second Derivation<a hidden class=anchor aria-hidden=true href=#our-second-derivation>#</a></h4><p>The following is a simple <code>hello-drv</code> derivation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>nix-repl<span style=color:#f92672>&gt;</span> hello-drv <span style=color:#f92672>=</span> nixpkgs<span style=color:#f92672>.</span>stdenv<span style=color:#f92672>.</span>mkDerivation {
</span></span><span style=display:flex><span>            name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;hello.txt&#34;</span>;
</span></span><span style=display:flex><span>            unpackPhase <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;true&#34;</span>;
</span></span><span style=display:flex><span>            installPhase <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>              echo -n &#34;Hello World!&#34; &gt; $out
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            &#39;&#39;</span>;
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>nix-repl<span style=color:#f92672>&gt;</span> hello-drv
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>«</span>derivation <span style=color:#e6db74>/nix/store/ad6c51ia15p9arjmvvqkn9fys9sf1kdw-hello.txt.drv</span><span style=color:#960050;background-color:#1e0010>»</span>
</span></span></code></pre></div><ul><li>Derivations have a <code>.drv</code> suffix, as you can see the result of calling
<code>hello-drv</code> is the nix store path to a derivation.</li></ul><h4 id=links-to-articles-about-derivations>Links To Articles about Derivations<a hidden class=anchor aria-hidden=true href=#links-to-articles-about-derivations>#</a></h4><ul><li><p><a href=https://nixos.org/guides/nix-pills/06-our-first-derivation>NixPillsOurFirstDerivation</a></p></li><li><p><a href=https://nixos.org/guides/nix-pills/07-working-derivation>NixPills-WorkingDerivation</a></p></li><li><p><a href=https://nix.dev/manual/nix/2.24/language/derivations>nix.dev-Derivations</a></p></li><li><p><a href=https://nix.dev/tutorials/packaging-existing-software>nix.dev-packagingExistingSoftware</a></p></li><li><p><a href=https://ianthehenry.com/posts/how-to-learn-nix/my-first-derivation/>howToLearnNix-MyFirstDerivation</a></p></li><li><p><a href=https://ianthehenry.com/posts/how-to-learn-nix/derivations-in-detail/>howToLearnNix-DerivationsInDetail</a></p></li><li><p><a href=https://www.sam.today/blog/creating-a-super-simple-derivation-learning-nix-pt-3>Sparky/blog-creatingASuperSimpleDerivation</a> # How to learn Nix</p></li><li><p><a href=https://www.sam.today/blog/derivations-102-learning-nix-pt-4>Sparky/blog-Derivations102</a></p></li><li><p><a href=https://scrive.github.io/nix-workshop/04-derivations/01-derivation-basics.html>ScriveNixWorkshop-nixDerivationBasics</a></p></li><li><p><a href=https://zero-to-nix.com/concepts/derivations/>zeroToNix-Derivations</a></p></li><li><p><a href=https://www.tweag.io/blog/2021-02-17-derivation-outputs-and-output-paths/>Tweag-derivationOutputs</a></p></li><li><p><a href=https://ayats.org/blog/nix-tuto-2>theNixLectures-Derivations</a></p></li><li><p><a href=https://bmcgee.ie/posts/2023/02/nix-what-are-fixed-output-derivations-and-why-use-them/>bmcgee-whatAreFixed-OutputDerivations</a></p></li></ul></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://tsawyer87.github.io/>NixOS Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>