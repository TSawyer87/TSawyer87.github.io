<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Understanding_nix_functions | NixOS Blog</title><meta name=keywords content><meta name=description content="Understanding Nix Functions

     


Functions are a fundamental concept in Nix and are prevalent throughout Nix code. Grasping how they work is crucial for understanding and writing Nix expressions.
The Single-Argument Nature of Nix Functions
A key concept to understand is that in Nix, every function conceptually takes exactly one argument. What might appear as multi-argument functions are actually achieved through a technique called currying, where a series of nested single-argument functions are used."><meta name=author content="T Sawyer"><link rel=canonical href=https://tsawyer87.github.io/posts/understanding_nix_functions/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://tsawyer87.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://tsawyer87.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://tsawyer87.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://tsawyer87.github.io/apple-touch-icon.png><link rel=mask-icon href=https://tsawyer87.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://tsawyer87.github.io/posts/understanding_nix_functions/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://tsawyer87.github.io/posts/understanding_nix_functions/"><meta property="og:site_name" content="NixOS Blog"><meta property="og:title" content="Understanding_nix_functions"><meta property="og:description" content="Understanding Nix Functions Functions are a fundamental concept in Nix and are prevalent throughout Nix code. Grasping how they work is crucial for understanding and writing Nix expressions.
The Single-Argument Nature of Nix Functions A key concept to understand is that in Nix, every function conceptually takes exactly one argument. What might appear as multi-argument functions are actually achieved through a technique called currying, where a series of nested single-argument functions are used."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-14T19:17:32-04:00"><meta property="article:modified_time" content="2025-05-14T19:17:32-04:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Understanding_nix_functions"><meta name=twitter:description content="Understanding Nix Functions

     


Functions are a fundamental concept in Nix and are prevalent throughout Nix code. Grasping how they work is crucial for understanding and writing Nix expressions.
The Single-Argument Nature of Nix Functions
A key concept to understand is that in Nix, every function conceptually takes exactly one argument. What might appear as multi-argument functions are actually achieved through a technique called currying, where a series of nested single-argument functions are used."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tsawyer87.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Understanding_nix_functions","item":"https://tsawyer87.github.io/posts/understanding_nix_functions/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Understanding_nix_functions","name":"Understanding_nix_functions","description":"Understanding Nix Functions Functions are a fundamental concept in Nix and are prevalent throughout Nix code. Grasping how they work is crucial for understanding and writing Nix expressions.\nThe Single-Argument Nature of Nix Functions A key concept to understand is that in Nix, every function conceptually takes exactly one argument. What might appear as multi-argument functions are actually achieved through a technique called currying, where a series of nested single-argument functions are used.\n","keywords":[],"articleBody":"Understanding Nix Functions Functions are a fundamental concept in Nix and are prevalent throughout Nix code. Grasping how they work is crucial for understanding and writing Nix expressions.\nThe Single-Argument Nature of Nix Functions A key concept to understand is that in Nix, every function conceptually takes exactly one argument. What might appear as multi-argument functions are actually achieved through a technique called currying, where a series of nested single-argument functions are used.\nIdentifying Function Structure The Colon The colon (:) acts as a clear separator within a function definition:\nLeft of the Colon: This is the function’s argument. It’s a placeholder name for a value that will be provided when the function is called. Right of the Colon: This is the function body. It’s the expression that will be evaluated when the function is invoked. Think of function arguments as naming values that aren’t known in advance. These names are placeholders that get filled with specific values when the function is used.\nExample:\ngreet = personName: \"Hello, ${personName}!\"; Here, personName is the argument (the placeholder).\n\"Hello, ${personName}!\", is the function body (the expression that uses the placeholder).\nWhen you call the function:\ngreet \"Anonymous\" # Evaluates to \"Hello, Anonymous!\" The value \"Anonymous\" is substituted for the personName placeholder within the function body.\nFunction Declarations Single and “Multiple” Arguments Single-Argument Functions\nThe simplest form of a Nix function takes a single argument:\ninc = x: x + 1; inc 5 # Evaluates to 6 x is the argument.\nx + 1 is the function body.\nSimulating Multiple Arguments: Currying\nTo create functions that appear to take multiple arguments, Nix uses currying. This involves nesting single-argument functions, where each function takes one argument and returns another function that takes the next argument, and so on.\nconcat = x: y: x + y; concat 6 6 # Evaluates to 12 Nix interprets the colons as separators for this chain of single-argument functions.\nUnderstanding the Chain:\nConsider the greeting function:\ngreeting = prefix: name: \"${prefix}, ${name}!\"; This is effectively a chain:\nOuter Function: prefix: (name: \"${prefix}, ${name}!\") Takes one argument: prefix.\nIts body is another function definition: name: \"${prefix}, ${name}!\".\n2 Inner Function: name: \"${prefix}, ${name}!\"\nTakes one argument: name.\nIts body uses both its own argument (name) and the argument from the outer function’s scope (prefix).\nStep-by-Step Evaluation:\nWhen you call greeting \"Hello\" \"Alice\":\ngreeting \"Hello\": The greeting function is called with \"Hello\" as the prefix.\nThe outer function returns the inner function: name: \"Hello, ${name}!\" (where prefix is now fixed as `“Hello”`` in its scope).\n(greeting \"Hello\") \"Alice\": The resulting inner function is then called with \"Alice\" as the name.\nThe inner function evaluates its body: \"Hello, ${\"Alice\"}!\", resulting in \"Hello, Alice!\".\nKey Insight: Every colon in a function definition separates a single argument from its function body, even if that body is another function definition.\nPartial Application: Using Functions Incrementally\nBecause of currying, you can apply arguments to a Nix function one at a time. This is called partial application. When you provide only some of the expected arguments, you get a new function that “remembers” the provided arguments and waits for the rest.\nExample:\nUsing our greeting function again:\ngreeting = prefix: name: \"${prefix}, ${name}!\"; If we only provide the prefix:\nhelloGreeting = greeting \"Hello\"; helloGreeting is now a new function. It has already received the prefix argument (\"Hello\") and is waiting for the name argument. Calling helloGreeting:\nhelloGreeting \"Sally\" # Evaluates to \"Hello, Sally!\" Benefits of Partial Application:\nCreating Specialized Functions: You can create more specific functions from general ones by fixing some of their parameters.\nAdapting to Higher-Order Functions: Many functions that operate on other functions (like map and filter) expect functions with a certain number of arguments. Partial application allows you to adapt existing functions to fit these requirements.\nThe Function Nature of NixOS and Home Manager Modules It’s crucial to understand that most NixOS and Home Manager modules are fundamentally functions.\nThese module functions typically accept a single argument: an attribute set. Example:\nA simplified Nginx service module:\n{ config, lib, pkgs, ... }: { services.nginx.enable = true; services.nginx.package = pkgs.nginx; services.nginx.settings.\"http-port\" = \"8080\"; } The entire module definition is a function that takes one argument: { config, lib, pkgs, ... }.\nWhen this module is included in your configuration, the NixOS module system calls this function with a specific attribute set. This attribute set contains the current system configuration (config), the Nix standard library (lib), the available packages (pkgs), and other relevant information. The module then uses these values to define parts of your system.\nResources nix.dev Nix Lang Basics\nnix pills Functions and Imports\nzero-to-nix Nix Lang\nA tour of Nix “Functions”\nlearn Nix in y minutes\nnoogle function library\n","wordCount":"787","inLanguage":"en","datePublished":"2025-05-14T19:17:32-04:00","dateModified":"2025-05-14T19:17:32-04:00","author":{"@type":"Person","name":"T Sawyer"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://tsawyer87.github.io/posts/understanding_nix_functions/"},"publisher":{"@type":"Organization","name":"NixOS Blog","logo":{"@type":"ImageObject","url":"https://tsawyer87.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tsawyer87.github.io/ accesskey=h title="NixOS Blog (Alt + H)">NixOS Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Understanding_nix_functions</h1><div class=post-meta><span title='2025-05-14 19:17:32 -0400 EDT'>May 14, 2025</span>&nbsp;·&nbsp;T Sawyer</div></header><div class=post-content><h1 id=understanding-nix-functions>Understanding Nix Functions<a hidden class=anchor aria-hidden=true href=#understanding-nix-functions>#</a></h1><figure><img loading=lazy src=/images/nixLogo.png alt=NixFlakeLogo width=500></figure><p>Functions are a fundamental concept in Nix and are prevalent throughout Nix code. Grasping how they work is crucial for understanding and writing Nix expressions.</p><h2 id=the-single-argument-nature-of-nix-functions>The Single-Argument Nature of Nix Functions<a hidden class=anchor aria-hidden=true href=#the-single-argument-nature-of-nix-functions>#</a></h2><p>A key concept to understand is that in Nix, every function conceptually takes <strong>exactly one argument</strong>. What might appear as multi-argument functions are actually achieved through a technique called <strong>currying</strong>, where a series of nested single-argument functions are used.</p><h2 id=identifying-function-structure-the-colon>Identifying Function Structure The Colon<a hidden class=anchor aria-hidden=true href=#identifying-function-structure-the-colon>#</a></h2><p>The colon (<code>:</code>) acts as a clear separator within a function definition:</p><ul><li><strong>Left of the Colon:</strong> This is the function&rsquo;s <strong>argument</strong>. It&rsquo;s a placeholder name for a value that will be provided when the function is called.</li><li><strong>Right of the Colon:</strong> This is the <strong>function body</strong>. It&rsquo;s the expression that will be evaluated when the function is invoked.</li></ul><p><strong>Think of function arguments as naming values that aren&rsquo;t known in advance.</strong> These names are placeholders that get filled with specific values when the function is used.</p><p><strong>Example:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>greet <span style=color:#f92672>=</span> personName: <span style=color:#e6db74>&#34;Hello, </span><span style=color:#e6db74>${</span>personName<span style=color:#e6db74>}</span><span style=color:#e6db74>!&#34;</span>;
</span></span></code></pre></div><ul><li><p>Here, <code>personName</code> is the <strong>argument</strong> (the placeholder).</p></li><li><p><code>"Hello, ${personName}!"</code>, is the <strong>function body</strong> (the expression that
uses the placeholder).</p></li></ul><p>When you call the function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>greet <span style=color:#e6db74>&#34;Anonymous&#34;</span>  <span style=color:#75715e># Evaluates to &#34;Hello, Anonymous!&#34;</span>
</span></span></code></pre></div><p>The value <code>"Anonymous"</code> is substituted for the <code>personName</code> placeholder within
the function body.</p><h2 id=function-declarations-single-and-multiple-arguments>Function Declarations Single and &ldquo;Multiple&rdquo; Arguments<a hidden class=anchor aria-hidden=true href=#function-declarations-single-and-multiple-arguments>#</a></h2><p><strong>Single-Argument Functions</strong></p><p>The simplest form of a Nix function takes a single argument:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>inc <span style=color:#f92672>=</span> x: x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>inc <span style=color:#ae81ff>5</span>  <span style=color:#75715e># Evaluates to 6</span>
</span></span></code></pre></div><ul><li><p><code>x</code> is the argument.</p></li><li><p><code>x + 1</code> is the function body.</p></li></ul><p><strong>Simulating Multiple Arguments: Currying</strong></p><p>To create functions that appear to take multiple arguments, Nix uses currying.
This involves nesting single-argument functions, where each function takes one
argument and returns another function that takes the next argument, and so on.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>concat <span style=color:#f92672>=</span> x: y: x <span style=color:#f92672>+</span> y;
</span></span><span style=display:flex><span>concat <span style=color:#ae81ff>6</span> <span style=color:#ae81ff>6</span>    <span style=color:#75715e># Evaluates to 12</span>
</span></span></code></pre></div><p>Nix interprets the colons as separators for this chain of single-argument
functions.</p><p><strong>Understanding the Chain:</strong></p><p>Consider the <code>greeting</code> function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>greeting <span style=color:#f92672>=</span> prefix: name: <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>prefix<span style=color:#e6db74>}</span><span style=color:#e6db74>, </span><span style=color:#e6db74>${</span>name<span style=color:#e6db74>}</span><span style=color:#e6db74>!&#34;</span>;
</span></span></code></pre></div><p>This is effectively a chain:</p><ol><li><strong>Outer Function</strong>: <code>prefix: (name: "${prefix}, ${name}!")</code></li></ol><ul><li><p>Takes one argument: <code>prefix</code>.</p></li><li><p>Its body is another function definition: name: <code>"${prefix}, ${name}!"</code>.</p></li></ul><p>2 <strong>Inner Function:</strong> <code>name: "${prefix}, ${name}!"</code></p><ul><li><p>Takes one argument: <code>name</code>.</p></li><li><p>Its body uses both its own argument (<code>name</code>) and the argument from the
outer function&rsquo;s scope (prefix).</p></li></ul><p><strong>Step-by-Step Evaluation:</strong></p><p>When you call <code>greeting "Hello" "Alice"</code>:</p><ol><li><code>greeting "Hello"</code>:</li></ol><ul><li><p>The <code>greeting</code> function is called with <code>"Hello"</code> as the <code>prefix</code>.</p></li><li><p>The outer function returns the inner function:
<code>name: "Hello, ${name}!"</code> (where <code>prefix</code> is now fixed as `&ldquo;Hello&rdquo;`` in its
scope).</p></li></ul><ol start=2><li><code>(greeting "Hello") "Alice"</code>:</li></ol><ul><li><p>The resulting inner function is then called with <code>"Alice"</code> as the <code>name</code>.</p></li><li><p>The inner function evaluates its body: <code>"Hello, ${"Alice"}!"</code>, resulting in
<code>"Hello, Alice!"</code>.</p></li></ul><p><strong>Key Insight</strong>: Every colon in a function definition separates a single
argument from its function body, even if that body is another function
definition.</p><p><strong>Partial Application: Using Functions Incrementally</strong></p><p>Because of currying, you can apply arguments to a Nix function one at a time.
This is called partial application. When you provide only some of the expected
arguments, you get a new function that &ldquo;remembers&rdquo; the provided arguments and
waits for the rest.</p><p><strong>Example:</strong></p><p>Using our <code>greeting</code> function again:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>greeting <span style=color:#f92672>=</span> prefix: name: <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>prefix<span style=color:#e6db74>}</span><span style=color:#e6db74>, </span><span style=color:#e6db74>${</span>name<span style=color:#e6db74>}</span><span style=color:#e6db74>!&#34;</span>;
</span></span></code></pre></div><p>If we only provide the prefix:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>helloGreeting <span style=color:#f92672>=</span> greeting <span style=color:#e6db74>&#34;Hello&#34;</span>;
</span></span></code></pre></div><ul><li><code>helloGreeting</code> is now a new function. It has already received the <code>prefix</code>
argument (<code>"Hello"</code>) and is waiting for the <code>name</code> argument.</li></ul><p>Calling <code>helloGreeting</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>helloGreeting <span style=color:#e6db74>&#34;Sally&#34;</span> <span style=color:#75715e># Evaluates to &#34;Hello, Sally!&#34;</span>
</span></span></code></pre></div><p><strong>Benefits of Partial Application:</strong></p><ul><li><p><strong>Creating Specialized Functions</strong>: You can create more specific functions
from general ones by fixing some of their parameters.</p></li><li><p><strong>Adapting to Higher-Order Functions</strong>: Many functions that operate on other
functions (like <code>map</code> and <code>filter</code>) expect functions with a certain number of
arguments. Partial application allows you to adapt existing functions to fit
these requirements.</p></li></ul><h3 id=the-function-nature-of-nixos-and-home-manager-modules>The Function Nature of NixOS and Home Manager Modules<a hidden class=anchor aria-hidden=true href=#the-function-nature-of-nixos-and-home-manager-modules>#</a></h3><p>It&rsquo;s crucial to understand that most NixOS and Home Manager modules are
fundamentally <strong>functions</strong>.</p><ul><li>These module functions typically accept a single argument: an
<strong>attribute set</strong>.</li></ul><p><strong>Example</strong>:</p><p>A simplified Nginx service module:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>{ config<span style=color:#f92672>,</span> lib<span style=color:#f92672>,</span> pkgs<span style=color:#f92672>,</span> <span style=color:#f92672>...</span> }: {
</span></span><span style=display:flex><span>services<span style=color:#f92672>.</span>nginx<span style=color:#f92672>.</span>enable <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>services<span style=color:#f92672>.</span>nginx<span style=color:#f92672>.</span>package <span style=color:#f92672>=</span> pkgs<span style=color:#f92672>.</span>nginx;
</span></span><span style=display:flex><span>services<span style=color:#f92672>.</span>nginx<span style=color:#f92672>.</span>settings<span style=color:#f92672>.</span><span style=color:#e6db74>&#34;http-port&#34;</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;8080&#34;</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><p>The entire module definition is a function that takes one argument:
<code>{ config, lib, pkgs, ... }</code>.</p></li><li><p>When this module is included in your configuration, the NixOS module system
calls this function with a specific attribute set. This attribute set contains
the current system configuration (<code>config</code>), the Nix standard library (<code>lib</code>),
the available packages (<code>pkgs</code>), and other relevant information. The module
then uses these values to define parts of your system.</p></li></ul><h3 id=resources>Resources<a hidden class=anchor aria-hidden=true href=#resources>#</a></h3><ul><li><p><a href=https://nix.dev/tutorials/nix-language.html>nix.dev Nix Lang Basics</a></p></li><li><p><a href=https://nixos.org/guides/nix-pills/05-functions-and-imports.html>nix pills Functions and Imports</a></p></li><li><p><a href=https://zero-to-nix.com/concepts/nix-language/>zero-to-nix Nix Lang</a></p></li><li><p><a href="https://nixcloud.io/tour/?id=functions%2Fintroduction">A tour of Nix &ldquo;Functions&rdquo;</a></p></li><li><p><a href=https://learnxinyminutes.com/nix/>learn Nix in y minutes</a></p></li><li><p><a href=https://noogle.dev/>noogle function library</a></p></li></ul></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://tsawyer87.github.io/>NixOS Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>