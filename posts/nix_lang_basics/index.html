<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Nix_lang_basics | NixOS Blog</title><meta name=keywords content><meta name=description content="The Nix Language
Nix as a programming language can be thought of as a kind of &ldquo;JSON, but with
functions&rdquo;.
All statements are declarative, meaning that there&rsquo;s no sequential flow of
instructions that makes up a Nix package. Instead, functions are called that
assign values to fields in attribute sets, which in turn may get assigned to
other values.
How does Nix work
Nix is a pure, functional, lazy, declarative, and reproducible programming
language."><meta name=author content="T Sawyer"><link rel=canonical href=https://tsawyer87.github.io/posts/nix_lang_basics/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://tsawyer87.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://tsawyer87.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://tsawyer87.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://tsawyer87.github.io/apple-touch-icon.png><link rel=mask-icon href=https://tsawyer87.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://tsawyer87.github.io/posts/nix_lang_basics/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://tsawyer87.github.io/posts/nix_lang_basics/"><meta property="og:site_name" content="NixOS Blog"><meta property="og:title" content="Nix_lang_basics"><meta property="og:description" content="The Nix Language Nix as a programming language can be thought of as a kind of “JSON, but with functions”.
All statements are declarative, meaning that there’s no sequential flow of instructions that makes up a Nix package. Instead, functions are called that assign values to fields in attribute sets, which in turn may get assigned to other values.
How does Nix work Nix is a pure, functional, lazy, declarative, and reproducible programming language."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-14T19:28:12-04:00"><meta property="article:modified_time" content="2025-05-14T19:28:12-04:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Nix_lang_basics"><meta name=twitter:description content="The Nix Language
Nix as a programming language can be thought of as a kind of &ldquo;JSON, but with
functions&rdquo;.
All statements are declarative, meaning that there&rsquo;s no sequential flow of
instructions that makes up a Nix package. Instead, functions are called that
assign values to fields in attribute sets, which in turn may get assigned to
other values.
How does Nix work
Nix is a pure, functional, lazy, declarative, and reproducible programming
language."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tsawyer87.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Nix_lang_basics","item":"https://tsawyer87.github.io/posts/nix_lang_basics/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Nix_lang_basics","name":"Nix_lang_basics","description":"The Nix Language Nix as a programming language can be thought of as a kind of \u0026ldquo;JSON, but with functions\u0026rdquo;.\nAll statements are declarative, meaning that there\u0026rsquo;s no sequential flow of instructions that makes up a Nix package. Instead, functions are called that assign values to fields in attribute sets, which in turn may get assigned to other values.\nHow does Nix work Nix is a pure, functional, lazy, declarative, and reproducible programming language.\n","keywords":[],"articleBody":"The Nix Language Nix as a programming language can be thought of as a kind of “JSON, but with functions”.\nAll statements are declarative, meaning that there’s no sequential flow of instructions that makes up a Nix package. Instead, functions are called that assign values to fields in attribute sets, which in turn may get assigned to other values.\nHow does Nix work Nix is a pure, functional, lazy, declarative, and reproducible programming language.\nConcept Description Pure Functions don’t cause side effects. Functional Functions can be passed as arguments and returned as results. Lazy Not evaluated until needed to complete a computation. Declarative Describing a system outcome. Reproducible Operations that are performed twice return same results ❗ Important: In Nix, everything is an expression, there are no statements. This is common in functional languages. ❗ Important: Values in Nix are immutable.\nIn Nix, the process of managing software starts with package definitions. These are files written in the Nix language that describe how a particular piece of software should be built. These package definitions, when processed by Nix, are translated into derivations.\nAt its core, a derivation in Nix is a blueprint or a recipe that describes how to build a specific software package or any other kind of file or directory. It’s a declarative specification of:\nInputs: What existing files or other derivations are needed as dependencies.\nBuild Steps: The commands that need to be executed to produce the desired output.\nEnvironment: The specific environment (e.g., build tools, environment variables) required for the build process.\nOutputs: The resulting files or directories that the derivation produces.\nThink of a package definition as the initial instructions, and the derivation as the detailed, low-level plan that Nix uses to actually perform the build.\"\nSyntax Basics Nix Language Overview\nBasics of the Language Pill\nDashes are allowed as identifiers:\nnix-repl\u003e a-b error: undefined variable `a-b' at (string):1:1 nix-repl\u003e a - b error: undefined variable `a' at (string):1:1 a-b is parsed as an identifier, not as subtraction.\nStrings: Strings are enclosed in double quotes (\") or two single quotes ('').\nnix-repl\u003e \"stringDaddy\" \"stringDaddy\" nix-repl\u003e ''stringMoma'' \"stringMoma\" String Interpolation: Is a language feature where a string, path, or attribute name can contain expressions enclosed in ${ }. This construct is called interpolated string, and the expression inside is an interpolated expression.string interpolation.\nRather than writing:\n\"--with-freetype2-library=\" + freetype + \"/lib\" where freetype is a derivation, you could instead write:\n\"--with-freetype2-library=${freetype}/lib\" And the above expression will be translated to the former.\nInterpolated Expression: An expression that is interpolated must evaluate to one of the following:\na string\na path\nan attribute set that has a __toString attribute or an outPath attribute.\n__toString must be a function that takes an attribute set itself and returns a string.\noutPath must be a string\nThis includes derivations or flake inputs.\nA path in an interpolated expression is first copied into the Nix store, and the resulting string is the store path of the newly created store object.\nmkdir foo reference the empty directory in an interpolated expression:\n\"${./foo}\" Output: \"/nix/store/2hhl2nz5v0khbn06ys82nrk99aa1xxdw-foo\"\nAttribute sets are all over Nix code, they are name-value pairs wrapped in curly braces, where the names must be unique: { string = \"hello\"; int = 8; } Attribute names usually don’t need quotes.\nList elements are separated by white space.\nprograms = { bat.enable = true; } The bat.enable is called dot notation. The above command can be written a few ways: programs.bat.enable = true; # using dot notation # or programs = { # using nested attribut sets. bat = { enable = true; } } You will sometimes see attribute sets with rec prepended. This allows access to attributes within the set:\nrec { one = 1; two = one + 1; three = two + 1; } Without rec, this command would fail because we are trying to use an attribute that is defined within this attribute set. You would get an undefined variable ‘one’ error. Inheriting Attributes\nlet x = 123; in { inherit x; y = 456; } is equivalent to\nlet x = 123; in { x = x; y = 456; } Both evaluate to:\n{ x = 123; y = 456; } ❗: This works because x is added to the lexical scope by the let construct.\ninherit x y z; inherit (src-set) a b c; is equivalent to:\nx = x; y = y; z = z; a = src-set.a; b = src-set.b; c = src-set.c In a let expression, inherit can be used to selectively bring specific attributes of a set into scope:\nlet x = { a = 1; b = 2; }; inherit (builtins) attrNames; in { names = attrNames x; } is equivalent to:\nlet x = { a = 1; b = 2; }; in { names = builtins.attrNames x; } Both evaluate to:\n{ names [ \"a\" \"b\" ]; } If expressions:\nnix-repl\u003e a = 6 nix-repl\u003e b = 10 nix-repl\u003e if a \u003e b then \"yes\" else \"no\" \"no\" Let expressions:\nlet a = \"foo\"; b = \"fighter\"; in a + b \"foofighter\" # flake.nix outputs = my-inputs @ { self, nixpkgs, treefmt-nix, ... }: let system = \"x86_64-linux\"; host = \"magic\"; in { ## Outputs go here } # nvf.nix { pkgs, inputs, config, lib, ... }: let cfg = config.custom.nvfModule; in { options.custom.nvfModule.enable = lib.mkOption { type = lib.types.bool; default = false; description = \"Enable the nvf nvim configuration\"; }; } With expressions:\nnix-repl\u003e longName = { a = 3; b = 4; } nix-repl\u003e longName.a + longName.b 7 nix-repl\u003e with longName; a + b 7 # utils.nix { pkgs, ... }: { environment.systemPackages = with pkgs; [ rustup evcxr nix-prefetch-git ]; } Laziness:\nNix evaluates expressions only when needed. This is a great feature when working with packages. nix-repl\u003e let a = builtins.div 4 0; b = 6; in b 6 Since a isn’t needed, there’s no error about division by zero, because the expression is not in need to be evaluated. That’s why we can have all the packages defined on demand, yet have acces to specific packages very quickly. Some of these examples came from the Nix pill series. Functions:\nThe code below calls a function called my_function with the parameters 2 and 3, and assigns its output to the my_value field:\n{ my_value = my_function 2 3; } Functions are defined using this syntax, where x and y are attributes passed into the function:\n{ my_function = x: y: x + y; } The body of the function automatically returns the result of the function. Functions are called by spaces between it and its parameters. No commas are needed to separate parameters. let negate = x: !x; concat = x: y: x + y; in if negate true then concat \"foo\" \"bar\" else \"\" negate = x: !x; This defines a function named negate that takes one argument x and returns its logical negation (using !)\nconcat = x: y: x + y defines a function that takes two arguments, x and y, and returns their string concatenation. Notice how Nix handles multi-argument functions through currying – it’s a function that returns another function. This was a little confusing to me, I’m thinking how does it return a function if concat 1 2 returns 3… x: ...: This part says that concat takes one argument, which we’ve named x.\ny: x + y: The result of the first part isn’t the final value. Instead, it’s another function. This inner function takes one argument, which we’ve named y, and then it adds x and y.\nWhen you do concat 1 you’re applying the concat function to the argument 1. This returns the inner function, where x is now fixed as 1. The inner function is essentially waiting for its y argument to be provided.\nIt’s when you apply the second argument, 2, to this resulting function (concat 1) 2 that the addition 1 + 2 finally happens, giving us 3.\nIt’s like a chain of function applications:\nconcat takes x and returns a new function.\nThis new function takes y and returns the result of x + y.\nDerivations Again, a derivation is like a blueprint that describes how to build a specific software package or any other kind of file or directory.\nKey Characteristics of Derivations:\nDeclarative: You describe the desired outcome and the inputs, not the exact sequence of imperative steps. Nix figures out the necessary steps based on the builder and args.\nReproducible: Given the same inputs and build instructions, a derivation will always produce the same output. This is a cornerstone of Nix’s reproducibility.\nTracked by Nix: Nix keeps track of all derivations and their outputs in the Nix store. This allows for efficient management of dependencies and ensures that different packages don’t interfere with each other.\nContent-Addressed: The output of a derivation is stored in the Nix store under a unique path that is derived from the hash of all its inputs and build instructions. This means that if anything changes in the derivation, the output will have a different path.\nHello World Derivation Example:\n{ pkgs ? import {} }: pkgs.stdenv.mkDerivation { name = \"hello-world\"; src = null; # No source code needed buildPhase = '' echo \"Hello, World!\" \u003e $out ''; installPhase = '' mkdir -p $out/bin cp $out $out/bin/hello chmod +x $out/bin/hello ''; meta = { description = \"A simple Hello World program built with Nix\"; homepage = null; license = lib.licenses.unfree; # For simplicity maintainers = []; }; } { pkgs ? import {} }: This is a function that takes an optional argument pkgs. We need Nixpkgs to access standard build environments like stdenv.\npkgs.stdenv.mkDerivation { ... }: This calls the mkDerivation function from the standard environment (stdenv). mkDerivation is the most common way to define software packages in Nix.\nname = \"hello-world\";: Human-readable name of the derivation\nsrc = null: No external source code for this simple example\nThe rest are the build phases and package metadata.\nTo use the above derivation, save it as a .nix file (e.g. hello.nix). Then build the derivation using:\nnix build ./hello.nix Nix will execute the buildPhase and installPhase\nAfter a successful build, the output will be in the Nix store. You can find the exact path by looking at the output of the nix build command (it will be something like /nix/store/your-hash-hello-world).\nRun the “installed” program:\n./result/bin/hello This will execute the hello file from the Nix store and print “Hello, World!”. Here’s a simple Nix derivation that creates a file named hello in the Nix store containing the text “Hello, World!”:\nEvaluating Nix Files Use nix-instantiate --eval to evaluate the expression in a Nix file:\necho 1 + 2 \u003e file.nix nix-instantiate --eval file.nix 3 Note: --eval is required to evaluate the file and do nothing else. If --eval is omitted, nix-instantiate expects the expression in the given file to evaluate to a derivation.\nIf you don’t specify an argument, nix-instantiate --eval will try to read from default.nix in the current directory.\nResources nix.dev nixlang-basics\nlearn nix in y minutes\nnix onepager\nawesome-nix\nzero-to-nix nix lang\nnix-pills basics of nixlang\n","wordCount":"1864","inLanguage":"en","datePublished":"2025-05-14T19:28:12-04:00","dateModified":"2025-05-14T19:28:12-04:00","author":{"@type":"Person","name":"T Sawyer"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://tsawyer87.github.io/posts/nix_lang_basics/"},"publisher":{"@type":"Organization","name":"NixOS Blog","logo":{"@type":"ImageObject","url":"https://tsawyer87.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tsawyer87.github.io/ accesskey=h title="NixOS Blog (Alt + H)">NixOS Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
<a href=/index.xml title="RSS Feed"><img src=/images/rss.png alt="RSS Feed" style=width:24px;height:24px></a></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Nix_lang_basics</h1><div class=post-meta><span title='2025-05-14 19:28:12 -0400 EDT'>May 14, 2025</span>&nbsp;·&nbsp;T Sawyer</div></header><div class=post-content><h1 id=the-nix-language>The Nix Language<a hidden class=anchor aria-hidden=true href=#the-nix-language>#</a></h1><p>Nix as a programming language can be thought of as a kind of &ldquo;JSON, but with
functions&rdquo;.</p><p>All statements are declarative, meaning that there&rsquo;s no sequential flow of
instructions that makes up a Nix package. Instead, functions are called that
assign values to fields in attribute sets, which in turn may get assigned to
other values.</p><h2 id=how-does-nix-work>How does Nix work<a hidden class=anchor aria-hidden=true href=#how-does-nix-work>#</a></h2><p>Nix is a pure, functional, lazy, declarative, and reproducible programming
language.</p><table><thead><tr><th>Concept</th><th>Description</th></tr></thead><tbody><tr><td>Pure</td><td>Functions don&rsquo;t cause side effects.</td></tr><tr><td>Functional</td><td>Functions can be passed as arguments and returned as results.</td></tr><tr><td>Lazy</td><td>Not evaluated until needed to complete a computation.</td></tr><tr><td>Declarative</td><td>Describing a system outcome.</td></tr><tr><td>Reproducible</td><td>Operations that are performed twice return same results</td></tr></tbody></table><blockquote><p>❗ Important: In Nix, everything is an expression, there are no statements.
This is common in functional languages. ❗ Important: Values in Nix are
immutable.</p></blockquote><ul><li><p>In Nix, the process of managing software starts with package definitions.
These are files written in the Nix language that describe how a particular
piece of software should be built. These package definitions, when processed
by Nix, are translated into derivations.</p></li><li><p>At its core, a derivation in Nix is a blueprint or a recipe that describes how
to build a specific software package or any other kind of file or directory.
It&rsquo;s a declarative specification of:</p></li><li><p>Inputs: What existing files or other derivations are needed as dependencies.</p></li><li><p>Build Steps: The commands that need to be executed to produce the desired
output.</p></li><li><p>Environment: The specific environment (e.g., build tools, environment
variables) required for the build process.</p></li><li><p>Outputs: The resulting files or directories that the derivation produces.</p></li></ul><p>Think of a package definition as the initial instructions, and the derivation as
the detailed, low-level plan that Nix uses to actually perform the build."</p><h2 id=syntax-basics>Syntax Basics<a hidden class=anchor aria-hidden=true href=#syntax-basics>#</a></h2><ul><li><p><a href=https://nix.dev/manual/nix/2.24/language/>Nix Language Overview</a></p></li><li><p><a href=https://nixos.org/guides/nix-pills/04-basics-of-language>Basics of the Language Pill</a></p></li><li><p>Dashes are allowed as identifiers:</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>nix-repl<span style=color:#f92672>&gt;</span> a-b
</span></span><span style=display:flex><span>error: undefined variable <span style=color:#960050;background-color:#1e0010>`</span>a-b&#39; at (string):<span style=color:#ae81ff>1</span>:<span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>nix-repl<span style=color:#f92672>&gt;</span> a<span style=color:#f92672> - </span>b
</span></span><span style=display:flex><span>error: undefined variable <span style=color:#960050;background-color:#1e0010>`</span>a&#39; at (string):<span style=color:#ae81ff>1</span>:<span style=color:#ae81ff>1</span>
</span></span></code></pre></div><ul><li><p><code>a-b</code> is parsed as an identifier, not as subtraction.</p></li><li><p><strong>Strings</strong>: Strings are enclosed in double quotes (<code>"</code>) or two single quotes
(<code>''</code>).</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>nix-repl<span style=color:#f92672>&gt;</span> <span style=color:#e6db74>&#34;stringDaddy&#34;</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;stringDaddy&#34;</span>
</span></span><span style=display:flex><span>nix-repl<span style=color:#f92672>&gt;</span> <span style=color:#e6db74>&#39;&#39;stringMoma&#39;&#39;</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;stringMoma&#34;</span>
</span></span></code></pre></div><p><strong>String Interpolation</strong>: Is a language feature where a string, path, or
attribute name can contain expressions enclosed in <code>${ }</code>. This construct is
called <em>interpolated string</em>, and the expression inside is an <em>interpolated
expression</em>.<a href=https://nix.dev/manual/nix/2.24/language/string-interpolation>string interpolation</a>.</p><p>Rather than writing:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span><span style=color:#e6db74>&#34;--with-freetype2-library=&#34;</span> <span style=color:#f92672>+</span> freetype <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;/lib&#34;</span>
</span></span></code></pre></div><p>where <code>freetype</code> is a derivation, you could instead write:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span><span style=color:#e6db74>&#34;--with-freetype2-library=</span><span style=color:#e6db74>${</span>freetype<span style=color:#e6db74>}</span><span style=color:#e6db74>/lib&#34;</span>
</span></span></code></pre></div><p>And the above expression will be translated to the former.</p><p><strong>Interpolated Expression</strong>: An expression that is interpolated must evaluate to
one of the following:</p><ul><li><p>a string</p></li><li><p>a path</p></li><li><p>an attribute set that has a <code>__toString</code> attribute or an <code>outPath</code> attribute.</p><ul><li><p><code>__toString</code> must be a function that takes an attribute set itself and
returns a string.</p></li><li><p><code>outPath</code> must be a string</p></li><li><p>This includes derivations or flake inputs.</p></li></ul></li></ul><p>A path in an interpolated expression is first copied into the Nix store, and the
resulting string is the store path of the newly created store object.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mkdir foo
</span></span></code></pre></div><p>reference the empty directory in an interpolated expression:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span><span style=color:#e6db74>./foo</span><span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</span></span></code></pre></div><p>Output: <code>"/nix/store/2hhl2nz5v0khbn06ys82nrk99aa1xxdw-foo"</code></p><ul><li><strong>Attribute sets</strong> are all over Nix code, they are name-value pairs wrapped in
curly braces, where the names must be unique:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>{
</span></span><span style=display:flex><span>  string <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;hello&#34;</span>;
</span></span><span style=display:flex><span>  int <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><p>Attribute names usually don&rsquo;t need quotes.</p></li><li><p>List elements are separated by white space.</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>programs <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  bat<span style=color:#f92672>.</span>enable <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>The <code>bat.enable</code> is called dot notation. The above command can be written a
few ways:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>programs<span style=color:#f92672>.</span>bat<span style=color:#f92672>.</span>enable <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>; <span style=color:#75715e># using dot notation</span>
</span></span><span style=display:flex><span><span style=color:#75715e># or</span>
</span></span><span style=display:flex><span>programs <span style=color:#f92672>=</span> {  <span style=color:#75715e># using nested attribut sets.</span>
</span></span><span style=display:flex><span>  bat <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    enable <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>You will sometimes see attribute sets with <code>rec</code> prepended. This allows access
to attributes within the set:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span><span style=color:#66d9ef>rec</span> {
</span></span><span style=display:flex><span>  one <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  two <span style=color:#f92672>=</span> one <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  three <span style=color:#f92672>=</span> two <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>Without <code>rec</code>, this command would fail because we are trying to use an
attribute that is defined within this attribute set. You would get an
undefined variable &lsquo;one&rsquo; error.</li></ul><p><strong>Inheriting Attributes</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span><span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>123</span>; <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>inherit</span> x;
</span></span><span style=display:flex><span>  y <span style=color:#f92672>=</span> <span style=color:#ae81ff>456</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>is equivalent to</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span><span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>123</span>; <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  x <span style=color:#f92672>=</span> x;
</span></span><span style=display:flex><span>  y <span style=color:#f92672>=</span> <span style=color:#ae81ff>456</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Both evaluate to:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>{ x <span style=color:#f92672>=</span> <span style=color:#ae81ff>123</span>; y <span style=color:#f92672>=</span> <span style=color:#ae81ff>456</span>; }
</span></span></code></pre></div><blockquote><p>❗: This works because <code>x</code> is added to the lexical scope by the <code>let</code>
construct.</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span><span style=color:#66d9ef>inherit</span> x y z;
</span></span><span style=display:flex><span><span style=color:#66d9ef>inherit</span> (src-set) a b c;
</span></span></code></pre></div><p>is equivalent to:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>x <span style=color:#f92672>=</span> x; y <span style=color:#f92672>=</span> y; z <span style=color:#f92672>=</span> z;
</span></span><span style=display:flex><span>a <span style=color:#f92672>=</span> src-set<span style=color:#f92672>.</span>a; b <span style=color:#f92672>=</span> src-set<span style=color:#f92672>.</span>b; c <span style=color:#f92672>=</span> src-set<span style=color:#f92672>.</span>c
</span></span></code></pre></div><p>In a <code>let</code> expression, <code>inherit</code> can be used to selectively bring specific
attributes of a set into scope:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span><span style=color:#66d9ef>let</span>
</span></span><span style=display:flex><span>  x <span style=color:#f92672>=</span> { a <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; b <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; };
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>inherit</span> (builtins) attrNames;
</span></span><span style=display:flex><span><span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  names <span style=color:#f92672>=</span> attrNames x;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>is equivalent to:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span><span style=color:#66d9ef>let</span>
</span></span><span style=display:flex><span>  x <span style=color:#f92672>=</span> { a <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; b <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; };
</span></span><span style=display:flex><span><span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  names <span style=color:#f92672>=</span> builtins<span style=color:#f92672>.</span>attrNames x;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Both evaluate to:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>{ names [ <span style=color:#e6db74>&#34;a&#34;</span> <span style=color:#e6db74>&#34;b&#34;</span> ]; }
</span></span></code></pre></div><p><strong>If expressions</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>nix-repl<span style=color:#f92672>&gt;</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>6</span>
</span></span><span style=display:flex><span>nix-repl<span style=color:#f92672>&gt;</span> b <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>nix-repl<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>if</span> a <span style=color:#f92672>&gt;</span> b <span style=color:#66d9ef>then</span> <span style=color:#e6db74>&#34;yes&#34;</span> <span style=color:#66d9ef>else</span> <span style=color:#e6db74>&#34;no&#34;</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;no&#34;</span>
</span></span></code></pre></div><p><strong>Let expressions</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span><span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;foo&#34;</span>; b <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;fighter&#34;</span>; <span style=color:#66d9ef>in</span> a <span style=color:#f92672>+</span> b
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;foofighter&#34;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span><span style=color:#75715e># flake.nix</span>
</span></span><span style=display:flex><span>outputs <span style=color:#f92672>=</span> my-inputs <span style=color:#f92672>@</span> {
</span></span><span style=display:flex><span>  self<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>  nixpkgs<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>  treefmt-nix<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>}: <span style=color:#66d9ef>let</span>
</span></span><span style=display:flex><span>     system <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;x86_64-linux&#34;</span>;
</span></span><span style=display:flex><span>     host <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;magic&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>in</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>## Outputs go here</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span><span style=color:#75715e># nvf.nix</span>
</span></span><span style=display:flex><span>{ pkgs<span style=color:#f92672>,</span> inputs<span style=color:#f92672>,</span> config<span style=color:#f92672>,</span> lib<span style=color:#f92672>,</span> <span style=color:#f92672>...</span> }: <span style=color:#66d9ef>let</span>
</span></span><span style=display:flex><span>  cfg <span style=color:#f92672>=</span> config<span style=color:#f92672>.</span>custom<span style=color:#f92672>.</span>nvfModule;
</span></span><span style=display:flex><span><span style=color:#66d9ef>in</span> {
</span></span><span style=display:flex><span>  options<span style=color:#f92672>.</span>custom<span style=color:#f92672>.</span>nvfModule<span style=color:#f92672>.</span>enable <span style=color:#f92672>=</span> lib<span style=color:#f92672>.</span>mkOption {
</span></span><span style=display:flex><span>    type <span style=color:#f92672>=</span> lib<span style=color:#f92672>.</span>types<span style=color:#f92672>.</span>bool;
</span></span><span style=display:flex><span>    default <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    description <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Enable the nvf nvim configuration&#34;</span>;
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>With expressions</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>nix-repl<span style=color:#f92672>&gt;</span> longName <span style=color:#f92672>=</span> { a <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>; b <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>; }
</span></span><span style=display:flex><span>nix-repl<span style=color:#f92672>&gt;</span> longName<span style=color:#f92672>.</span>a <span style=color:#f92672>+</span> longName<span style=color:#f92672>.</span>b
</span></span><span style=display:flex><span><span style=color:#ae81ff>7</span>
</span></span><span style=display:flex><span>nix-repl<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>with</span> longName; a <span style=color:#f92672>+</span> b
</span></span><span style=display:flex><span><span style=color:#ae81ff>7</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span><span style=color:#75715e># utils.nix</span>
</span></span><span style=display:flex><span>{ pkgs<span style=color:#f92672>,</span> <span style=color:#f92672>...</span> }: {
</span></span><span style=display:flex><span>  environment<span style=color:#f92672>.</span>systemPackages <span style=color:#f92672>=</span> <span style=color:#66d9ef>with</span> pkgs; [
</span></span><span style=display:flex><span>    rustup
</span></span><span style=display:flex><span>    evcxr
</span></span><span style=display:flex><span>    nix-prefetch-git
</span></span><span style=display:flex><span>  ];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Laziness</strong>:</p><ul><li>Nix evaluates expressions only when needed. This is a great feature when
working with packages.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>nix-repl<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> builtins<span style=color:#f92672>.</span>div <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>0</span>; b <span style=color:#f92672>=</span> <span style=color:#ae81ff>6</span>; <span style=color:#66d9ef>in</span> b
</span></span><span style=display:flex><span><span style=color:#ae81ff>6</span>
</span></span></code></pre></div><ul><li>Since <code>a</code> isn&rsquo;t needed, there&rsquo;s no error about division by zero, because the
expression is not in need to be evaluated. That&rsquo;s why we can have all the
packages defined on demand, yet have acces to specific packages very quickly.
Some of these examples came from the Nix pill series.</li></ul><p><strong>Functions</strong>:</p><p>The code below calls a function called <code>my_function</code> with the parameters <code>2</code> and
<code>3</code>, and assigns its output to the <code>my_value</code> field:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>{
</span></span><span style=display:flex><span>  my_value <span style=color:#f92672>=</span> my_function <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Functions are defined using this syntax, where <code>x</code> and <code>y</code> are attributes passed
into the function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>{
</span></span><span style=display:flex><span>  my_function <span style=color:#f92672>=</span> x: y: x <span style=color:#f92672>+</span> y;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>The body of the function automatically returns the result of the function.
Functions are called by spaces between it and its parameters. No commas are
needed to separate parameters.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span><span style=color:#66d9ef>let</span> negate <span style=color:#f92672>=</span> x: <span style=color:#f92672>!</span>x;
</span></span><span style=display:flex><span>    concat <span style=color:#f92672>=</span> x: y: x <span style=color:#f92672>+</span> y;
</span></span><span style=display:flex><span><span style=color:#66d9ef>in</span> <span style=color:#66d9ef>if</span> negate <span style=color:#66d9ef>true</span> <span style=color:#66d9ef>then</span> concat <span style=color:#e6db74>&#34;foo&#34;</span> <span style=color:#e6db74>&#34;bar&#34;</span> <span style=color:#66d9ef>else</span> <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>negate <span style=color:#f92672>=</span> x: <span style=color:#f92672>!</span>x;
</span></span></code></pre></div><p>This defines a function named <code>negate</code> that takes one argument <code>x</code> and returns
its logical negation (using <code>!</code>)</p><ul><li><code>concat = x: y: x + y</code> defines a function that takes two arguments, <code>x</code> and
<code>y</code>, and returns their string concatenation. Notice how Nix handles
multi-argument functions through currying &ndash; it&rsquo;s a function that returns
another function. This was a little confusing to me, I&rsquo;m thinking how does it
return a function if <code>concat 1 2</code> returns <code>3</code>&mldr;<ul><li><p><code>x: ...</code>: This part says that <code>concat</code> takes one argument, which we&rsquo;ve named
<code>x</code>.</p></li><li><p><code>y: x + y</code>: The result of the first part isn&rsquo;t the final value. Instead,
it&rsquo;s another function. This inner function takes one argument, which we&rsquo;ve
named <code>y</code>, and then it adds <code>x</code> and <code>y</code>.</p></li><li><p>When you do <code>concat 1</code> you&rsquo;re applying the <code>concat</code> function to the argument
<code>1</code>. This returns the inner function, where <code>x</code> is now fixed as <code>1</code>. The
inner function is essentially waiting for its <code>y</code> argument to be provided.</p></li><li><p>It&rsquo;s when you apply the second argument, <code>2</code>, to this resulting function
<code>(concat 1) 2</code> that the addition <code>1 + 2</code> finally happens, giving us <code>3</code>.</p></li></ul></li></ul><p>It&rsquo;s like a chain of function applications:</p><ul><li><p><code>concat</code> takes <code>x</code> and returns a new function.</p></li><li><p>This new function takes <code>y</code> and returns the result of <code>x + y</code>.</p></li></ul><h3 id=derivations>Derivations<a hidden class=anchor aria-hidden=true href=#derivations>#</a></h3><p>Again, a derivation is like a blueprint that describes how to build a specific
software package or any other kind of file or directory.</p><p><strong>Key Characteristics of Derivations:</strong></p><ul><li><p><strong>Declarative</strong>: You describe the desired outcome and the inputs, not the
exact sequence of imperative steps. Nix figures out the necessary steps based
on the builder and args.</p></li><li><p><strong>Reproducible</strong>: Given the same inputs and build instructions, a derivation
will always produce the same output. This is a cornerstone of Nix&rsquo;s
reproducibility.</p></li><li><p><strong>Tracked by Nix</strong>: Nix keeps track of all derivations and their outputs in
the Nix store. This allows for efficient management of dependencies and
ensures that different packages don&rsquo;t interfere with each other.</p></li><li><p><strong>Content-Addressed</strong>: The output of a derivation is stored in the Nix store
under a unique path that is derived from the hash of all its inputs and build
instructions. This means that if anything changes in the derivation, the
output will have a different path.</p></li></ul><p><strong>Hello World Derivation Example</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>{ pkgs <span style=color:#f92672>?</span> <span style=color:#f92672>import</span> <span style=color:#e6db74>&lt;nixpkgs&gt;</span> {} }:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>pkgs<span style=color:#f92672>.</span>stdenv<span style=color:#f92672>.</span>mkDerivation {
</span></span><span style=display:flex><span>  name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;hello-world&#34;</span>;
</span></span><span style=display:flex><span>  src <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>; <span style=color:#75715e># No source code needed</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  buildPhase <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    echo &#34;Hello, World!&#34; &gt; $out
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  &#39;&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  installPhase <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    mkdir -p $out/bin
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    cp $out $out/bin/hello
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    chmod +x $out/bin/hello
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  &#39;&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  meta <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    description <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;A simple Hello World program built with Nix&#34;</span>;
</span></span><span style=display:flex><span>    homepage <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    license <span style=color:#f92672>=</span> lib<span style=color:#f92672>.</span>licenses<span style=color:#f92672>.</span>unfree; <span style=color:#75715e># For simplicity</span>
</span></span><span style=display:flex><span>    maintainers <span style=color:#f92672>=</span> [];
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><p><code>{ pkgs ? import &lt;nixpkgs> {} }</code>: This is a function that takes an optional
argument <code>pkgs</code>. We need Nixpkgs to access standard build environments like
<code>stdenv</code>.</p></li><li><p><code>pkgs.stdenv.mkDerivation { ... }:</code> This calls the mkDerivation function from
the standard environment (stdenv). mkDerivation is the most common way to
define software packages in Nix.</p></li><li><p><code>name = "hello-world";</code>: Human-readable name of the derivation</p></li><li><p><code>src = null</code>: No external source code for this simple example</p></li><li><p>The rest are the build phases and package metadata.</p></li></ul><p>To use the above derivation, save it as a <code>.nix</code> file (e.g. <code>hello.nix</code>). Then
build the derivation using:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>nix build ./hello.nix
</span></span></code></pre></div><ul><li><p>Nix will execute the <code>buildPhase</code> and <code>installPhase</code></p></li><li><p>After a successful build, the output will be in the Nix store. You can find
the exact path by looking at the output of the nix build command (it will be
something like <code>/nix/store/your-hash-hello-world</code>).</p></li></ul><p>Run the &ldquo;installed&rdquo; program:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>./result/bin/hello
</span></span></code></pre></div><ul><li>This will execute the <code>hello</code> file from the Nix store and print &ldquo;Hello,
World!&rdquo;.</li></ul><p>Here&rsquo;s a simple Nix derivation that creates a file named hello in the Nix store
containing the text &ldquo;Hello, World!&rdquo;:</p><h3 id=evaluating-nix-files>Evaluating Nix Files<a hidden class=anchor aria-hidden=true href=#evaluating-nix-files>#</a></h3><p>Use <code>nix-instantiate --eval</code> to evaluate the expression in a Nix file:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>echo <span style=color:#ae81ff>1</span> + <span style=color:#ae81ff>2</span> &gt; file.nix
</span></span><span style=display:flex><span>nix-instantiate --eval file.nix
</span></span><span style=display:flex><span><span style=color:#ae81ff>3</span>
</span></span></code></pre></div><blockquote><p><strong>Note:</strong> <code>--eval</code> is required to evaluate the file and do nothing else. If
<code>--eval</code> is omitted, <code>nix-instantiate</code> expects the expression in the given
file to evaluate to a derivation.</p></blockquote><p>If you don&rsquo;t specify an argument, <code>nix-instantiate --eval</code> will try to read from
<code>default.nix</code> in the current directory.</p><h3 id=resources>Resources<a hidden class=anchor aria-hidden=true href=#resources>#</a></h3><ul><li><p><a href=https://nix.dev/tutorials/nix-language.html>nix.dev nixlang-basics</a></p></li><li><p><a href=https://learnxinyminutes.com/nix/>learn nix in y minutes</a></p></li><li><p><a href=https://github.com/tazjin/nix-1p>nix onepager</a></p></li><li><p><a href=https://github.com/nix-community/awesome-nix>awesome-nix</a></p></li><li><p><a href=https://zero-to-nix.com/concepts/nix-language/>zero-to-nix nix lang</a></p></li><li><p><a href=https://nixos.org/guides/nix-pills/04-basics-of-language.html>nix-pills basics of nixlang</a></p></li></ul></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://tsawyer87.github.io/>NixOS Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>