<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hacking_the_helix_flake | NixOS Blog</title><meta name=keywords content><meta name=description content="
Chapter 4.4
Understanding the Helix Flake and Modifying its Behavior

Understanding the Helix flake.nix
Top-Level Metadata
Inputs
Outputs Function
Common Setup -
Breaking Down helix/default.nix -
Making Actual Changes -
Another way to Modify Behavior




Understanding the Helix Flake and Modifying its Behavior
As we&rsquo;ve seen from previous examples, the helix editor repository includes a few
.nix files including a flake.nix. Their flake uses a lot of idiomatic Nix
code and advanced features. First I will break down their flake.nix and
default.nix to understand why they do certain things. And finally, we will
change the build to &ldquo;debug&rdquo; mode demonstrating how easily you can modify the
behavior of a package defined within a Nix flake without changing the original
source code or the upstream flake directly."><meta name=author content="T Sawyer"><link rel=canonical href=https://tsawyer87.github.io/posts/hacking_the_helix_flake/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://tsawyer87.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://tsawyer87.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://tsawyer87.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://tsawyer87.github.io/apple-touch-icon.png><link rel=mask-icon href=https://tsawyer87.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://tsawyer87.github.io/posts/hacking_the_helix_flake/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://tsawyer87.github.io/posts/hacking_the_helix_flake/"><meta property="og:site_name" content="NixOS Blog"><meta property="og:title" content="hacking_the_helix_flake"><meta property="og:description" content=" Chapter 4.4 Understanding the Helix Flake and Modifying its Behavior Understanding the Helix flake.nix Top-Level Metadata Inputs Outputs Function Common Setup - Breaking Down helix/default.nix - Making Actual Changes - Another way to Modify Behavior Understanding the Helix Flake and Modifying its Behavior As we’ve seen from previous examples, the helix editor repository includes a few .nix files including a flake.nix. Their flake uses a lot of idiomatic Nix code and advanced features. First I will break down their flake.nix and default.nix to understand why they do certain things. And finally, we will change the build to “debug” mode demonstrating how easily you can modify the behavior of a package defined within a Nix flake without changing the original source code or the upstream flake directly."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-30T19:23:32-04:00"><meta property="article:modified_time" content="2025-05-30T19:23:32-04:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="hacking_the_helix_flake"><meta name=twitter:description content="
Chapter 4.4
Understanding the Helix Flake and Modifying its Behavior

Understanding the Helix flake.nix
Top-Level Metadata
Inputs
Outputs Function
Common Setup -
Breaking Down helix/default.nix -
Making Actual Changes -
Another way to Modify Behavior




Understanding the Helix Flake and Modifying its Behavior
As we&rsquo;ve seen from previous examples, the helix editor repository includes a few
.nix files including a flake.nix. Their flake uses a lot of idiomatic Nix
code and advanced features. First I will break down their flake.nix and
default.nix to understand why they do certain things. And finally, we will
change the build to &ldquo;debug&rdquo; mode demonstrating how easily you can modify the
behavior of a package defined within a Nix flake without changing the original
source code or the upstream flake directly."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tsawyer87.github.io/posts/"},{"@type":"ListItem","position":2,"name":"hacking_the_helix_flake","item":"https://tsawyer87.github.io/posts/hacking_the_helix_flake/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"hacking_the_helix_flake","name":"hacking_the_helix_flake","description":" Chapter 4.4 Understanding the Helix Flake and Modifying its Behavior Understanding the Helix flake.nix Top-Level Metadata Inputs Outputs Function Common Setup - Breaking Down helix/default.nix - Making Actual Changes - Another way to Modify Behavior Understanding the Helix Flake and Modifying its Behavior As we\u0026rsquo;ve seen from previous examples, the helix editor repository includes a few .nix files including a flake.nix. Their flake uses a lot of idiomatic Nix code and advanced features. First I will break down their flake.nix and default.nix to understand why they do certain things. And finally, we will change the build to \u0026ldquo;debug\u0026rdquo; mode demonstrating how easily you can modify the behavior of a package defined within a Nix flake without changing the original source code or the upstream flake directly.\n","keywords":[],"articleBody":" Chapter 4.4 Understanding the Helix Flake and Modifying its Behavior Understanding the Helix flake.nix Top-Level Metadata Inputs Outputs Function Common Setup - Breaking Down helix/default.nix - Making Actual Changes - Another way to Modify Behavior Understanding the Helix Flake and Modifying its Behavior As we’ve seen from previous examples, the helix editor repository includes a few .nix files including a flake.nix. Their flake uses a lot of idiomatic Nix code and advanced features. First I will break down their flake.nix and default.nix to understand why they do certain things. And finally, we will change the build to “debug” mode demonstrating how easily you can modify the behavior of a package defined within a Nix flake without changing the original source code or the upstream flake directly.\nLet’s clone the Helix repository: git clone https://github.com/helix-editor/helix.git cd helix Enter the Development Shell: The Helix project’s flake.nix includes a devShells.default output, specifically designed for development.\nnix develop You’re now in a fully configured development environment: When you run nix develop, Nix builds and drops you into a shell environment with all the dependencies specified in devShells.default. This means you don’t have to manually install or manage tools like Rust, Cargo, or Clang—it’s all handled declaratively through Nix. You can now build and run the project using its standard tooling:\ncargo build cargo run Making Changes and Testing Them Since you’re in a reproducible environment, you can confidently hack on the project without worrying about your system setup. Try modifying some code in helix and rebuilding with Cargo. The Nix shell ensures consistency for every contributor or device you work on.\nRun Just the Binary If you only want to run the compiled program without entering the shell, use the nix run command:\nnix run This builds and runs the default package defined by the flake. In the case of Helix, this launches the hx editor directly.\nBuild Without Running To just build the project and get the path to the output binary:\nnix build You’ll find the compiled binary under ./result/bin.\nPinning and Reproducing Because the project uses a flake, you can ensure full reproducibility by pinning the inputs. For example, you can clone with –recurse-submodules and copy the flake.lock to ensure you’re using the same dependency versions as upstream. This is great for debugging or sharing exact builds.\n✅ Recap:\nWith flakes, projects like Helix provide everything you need for development and running in a single flake.nix. You can nix develop to get started hacking, nix run to quickly try it out, and nix build to produce binaries—all without installing or polluting your system.\nUnderstanding the Helix flake.nix The helix flake is full of idiomatic Nix code and displays some of the more advanced things a flake can provide:\n{ description = \"A post-modern text editor.\"; inputs = { nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\"; rust-overlay = { url = \"github:oxalica/rust-overlay\"; inputs.nixpkgs.follows = \"nixpkgs\"; }; }; outputs = { self, nixpkgs, rust-overlay, ... }: let inherit (nixpkgs) lib; systems = [ \"x86_64-linux\" \"aarch64-linux\" \"x86_64-darwin\" \"aarch64-darwin\" ]; eachSystem = lib.genAttrs systems; pkgsFor = eachSystem (system: import nixpkgs { localSystem.system = system; overlays = [(import rust-overlay) self.overlays.helix]; }); gitRev = self.rev or self.dirtyRev or null; in { packages = eachSystem (system: { inherit (pkgsFor.${system}) helix; /* The default Helix build. Uses the latest stable Rust toolchain, and unstable nixpkgs. The build inputs can be overridden with the following: packages.${system}.default.override { rustPlatform = newPlatform; }; Overriding a derivation attribute can be done as well: packages.${system}.default.overrideAttrs { buildType = \"debug\"; }; */ default = self.packages.${system}.helix; }); checks = lib.mapAttrs (system: pkgs: let # Get Helix's MSRV toolchain to build with by default. msrvToolchain = pkgs.pkgsBuildHost.rust-bin.fromRustupToolchainFile ./rust-toolchain.toml; msrvPlatform = pkgs.makeRustPlatform { cargo = msrvToolchain; rustc = msrvToolchain; }; in { helix = self.packages.${system}.helix.override { rustPlatform = msrvPlatform; }; }) pkgsFor; # Devshell behavior is preserved. devShells = lib.mapAttrs (system: pkgs: { default = let commonRustFlagsEnv = \"-C link-arg=-fuse-ld=lld -C target-cpu=native --cfg tokio_unstable\"; platformRustFlagsEnv = lib.optionalString pkgs.stdenv.isLinux \"-Clink-arg=-Wl,--no-rosegment\"; in pkgs.mkShell { inputsFrom = [self.checks.${system}.helix]; nativeBuildInputs = with pkgs; [ lld cargo-flamegraph rust-bin.nightly.latest.rust-analyzer ] ++ (lib.optional (stdenv.isx86_64 \u0026\u0026 stdenv.isLinux) cargo-tarpaulin) ++ (lib.optional stdenv.isLinux lldb) ++ (lib.optional stdenv.isDarwin darwin.apple_sdk.frameworks.CoreFoundation); shellHook = '' export RUST_BACKTRACE=\"1\" export RUSTFLAGS=\"''${RUSTFLAGS:-\"\"} ${commonRustFlagsEnv} ${platformRustFlagsEnv}\" ''; }; }) pkgsFor; overlays = { helix = final: prev: { helix = final.callPackage ./default.nix {inherit gitRev;}; }; default = self.overlays.helix; }; }; nixConfig = { extra-substituters = [\"https://helix.cachix.org\"]; extra-trusted-public-keys = [\"helix.cachix.org-1:ejp9KQpR1FBI2onstMQ34yogDm4OgU2ru6lIwPvuCVs=\"]; }; } Top-Level Metadata { description = \"A post-modern text editor.\"; } This sets a human-readable description for the flake. Inputs inputs = { nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\"; rust-overlay = { url = \"github:oxalica/rust-overlay\"; inputs.nixpkgs.follows = \"nixpkgs\"; }; }; nixpkgs: Uses the nixos-unstable branch of the Nixpkgs repository.\nrust-overlay: follows the same nixpkgs, ensuring compatibility between inputs.\nOutputs Function outputs = { self, nixpkgs, rust-overlay, ... }: This defines what this flake exports, including packages, devShells, etc. Common Setup let inherit (nixpkgs) lib; systems = [ ... ]; eachSystem = lib.genAttrs systems; systems: A list of the supported systems\neachSystem: A Helper to map over all platforms.\npkgsFor = eachSystem (system: import nixpkgs { localSystem.system = system; overlays = [(import rust-overlay) self.overlays.helix]; }); This imports nixpkgs for each system and applies overlays 📦 packages\npackages = eachSystem (system: { inherit (pkgsFor.${system}) helix; default = self.packages.${system}.helix; }); For each platform: Includes a helix package (defined in ./default.nix)\nSets default to helix (used by nix build, nix run)\nLet’s look at the helix default.nix:\n{ lib, rustPlatform, callPackage, runCommand, installShellFiles, git, gitRev ? null, grammarOverlays ? [], includeGrammarIf ? _: true, }: let fs = lib.fileset; src = fs.difference (fs.gitTracked ./.) (fs.unions [ ./.envrc ./rustfmt.toml ./screenshot.png ./book ./docs ./runtime ./flake.lock (fs.fileFilter (file: lib.strings.hasInfix \".git\" file.name) ./.) (fs.fileFilter (file: file.hasExt \"svg\") ./.) (fs.fileFilter (file: file.hasExt \"md\") ./.) (fs.fileFilter (file: file.hasExt \"nix\") ./.) ]); # Next we actually need to build the grammars and the runtime directory # that they reside in. It is built by calling the derivation in the # grammars.nix file, then taking the runtime directory in the git repo # and hooking symlinks up to it. grammars = callPackage ./grammars.nix {inherit grammarOverlays includeGrammarIf;}; runtimeDir = runCommand \"helix-runtime\" {} '' mkdir -p $out ln -s ${./runtime}/* $out rm -r $out/grammars ln -s ${grammars} $out/grammars ''; in rustPlatform.buildRustPackage (self: { cargoLock = { lockFile = ./Cargo.lock; # This is not allowed in nixpkgs but is very convenient here: it allows us to # avoid specifying `outputHashes` here for any git dependencies we might take # on temporarily. allowBuiltinFetchGit = true; }; nativeBuildInputs = [ installShellFiles git ]; buildType = \"release\"; name = with builtins; (fromTOML (readFile ./helix-term/Cargo.toml)).package.name; src = fs.toSource { root = ./.; fileset = src; }; # Helix attempts to reach out to the network and get the grammars. Nix doesn't allow this. HELIX_DISABLE_AUTO_GRAMMAR_BUILD = \"1\"; # So Helix knows what rev it is. HELIX_NIX_BUILD_REV = gitRev; doCheck = false; strictDeps = true; # Sets the Helix runtime dir to the grammars env.HELIX_DEFAULT_RUNTIME = \"${runtimeDir}\"; # Get all the application stuff in the output directory. postInstall = '' mkdir -p $out/lib installShellCompletion ${./contrib/completion}/hx.{bash,fish,zsh} mkdir -p $out/share/{applications,icons/hicolor/{256x256,scalable}/apps} cp ${./contrib/Helix.desktop} $out/share/applications/Helix.desktop cp ${./logo.svg} $out/share/icons/hicolor/scalable/apps/helix.svg cp ${./contrib/helix.png} $out/share/icons/hicolor/256x256/apps/helix.png ''; meta.mainProgram = \"hx\"; }) Breaking Down helix/default.nix This default.nix file is a Nix derivation that defines how to build the Helix editor itself. It’s designed to be called by the main flake.nix as part of its packages output.\nHere’s a breakdown of its components:\nFunction Arguments: { lib, rustPlatform, callPackage, runCommand, installShellFiles, git, gitRev ? null, grammarOverlays ? [], includeGrammarIf ? _: true, }: lib: The Nixpkgs lib (library) functions, essential for common operations like fileset and strings.\nrustPlatform: A helper function from Nixpkgs specifically for building Rust projects. It provides a buildRustPackage function, which simplifies the process significantly.\ncallPackage: A Nixpkgs function used to instantiate a Nix expression (like grammars.nix) with its dependencies automatically supplied from the current Nix environment.\nrunCommand: A Nixpkgs primitive that creates a derivation by running a shell command. It’s used here to construct the runtimeDir.\ninstallShellFiles: A utility from Nixpkgs for installing shell completion files.\ngit: The Git package, needed for determining the gitRev.\ngitRev ? null: The Git revision of the Helix repository. It’s an optional argument, defaulting to null. This is passed in from the main flake.nix.\ngrammarOverlays ? []: An optional list of overlays for grammars, allowing customization.\nincludeGrammarIf ? _: true: An optional function to control which grammars are included.\nLocal Variables (let ... in) let fs = lib.fileset; src = fs.difference (fs.gitTracked ./.) (fs.unions [ ./.envrc ./rustfmt.toml ./screenshot.png ./book ./docs ./runtime ./flake.lock (fs.fileFilter (file: lib.strings.hasInfix \".git\" file.name) ./.) (fs.fileFilter (file: file.hasExt \"svg\") ./.) (fs.fileFilter (file: file.hasExt \"md\") ./.) (fs.fileFilter (file: file.hasExt \"nix\") ./.) ]); grammars = callPackage ./grammars.nix { inherit grammarOverlays includeGrammarIf; }; runtimeDir = runCommand \"helix-runtime\" {} '' mkdir -p $out ln -s ${./runtime}/* $out rm -r $out/grammars ln -s ${grammars} $out/grammars ''; in fs = lib.fileset;: Aliases lib.fileset for convenient file set operations.\nsrc: This is a crucial part. It defines the source files that will be used to build Helix by:\nTaking all Git-tracked files in the current directory (fs.gitTracked ./.).\nExcluding configuration files (e.g., .envrc, flake.lock), documentation (.md), images (.svg), and Nix files (.nix) using fs.difference and fs.unions. This ensures a clean build input, reducing Nix store size and avoiding unnecessary rebuilds.\ngrammars: Builds syntax grammars by calling grammars.nix, passing grammarOverlays (for customizing grammar builds) and includeGrammarIf (a filter for selecting grammars).\nruntimeDir: Creates a runtime directory for Helix by:\nSymlinking the runtime directory from the source.\nReplacing the grammars subdirectory with a symlink to the grammars derivation, ensuring Helix uses Nix-managed grammars.\nThe Build Derivation (rustPlatform.buildRustPackage) The core of this default.nix is the rustPlatform.buildRustPackage call, which is a specialized builder for Rust projects:\nin rustPlatform.buildRustPackage (self: { cargoLock = { lockFile = ./Cargo.lock; # ... comments ... allowBuiltinFetchGit = true; }; cargoLock: Specifies how Cargo dependencies are handled.\nlockFile = ./Cargo.lock; Points to the Cargo.lock file for reproducible builds.\nallowBuiltinFetchGit = true: Allows Cargo to fetch Git dependencies directly from repositories specified in Cargo.lock. This is discouraged in Nixpkgs because it can break build reproducibility, but it’s used here for convenience during development, eliminating the need to manually specify outputHashes for Git dependencies.\nnativeBuildInputs = [ installShellFiles git ]; nativeBuildInputs: Are tools needed during the build process but not necessarily at runtime.\nbuildType = \"release\"; buildType: Specifies that Helix should be built in “release” mode (optimized).\nname = with builtins; (fromTOML (readFile ./helix-term/Cargo.toml)).package.name; src = fs.toSource { root = ./.; fileset = src; }; name: Dynamically sets the package name by reading it from the Cargo.toml file.\nsrc: Uses the src file set defined earlier as the source for the build.\n# Helix attempts to reach out to the network and get the grammars. Nix doesn't allow this. HELIX_DISABLE_AUTO_GRAMMAR_BUILD = \"1\"; # So Helix knows what rev it is. HELIX_NIX_BUILD_REV = gitRev; Environment Variables: Sets environment variables that Helix uses.\nHELIX_DISABLE_AUTO_GRAMMAR_BUILD = \"1\": Prevents Helix from downloading grammars during the build, as Nix’s sandboxed environment disallows network access. Instead, grammars are provided via the runtimeDir derivation.\nHELIX_NIX_BUILD_REV = gitRev: Embeds the specified Git revision (or null if unspecified) into the Helix binary, allowing Helix to display its version or commit hash.\ndoCheck = false; strictDeps = true; doCheck = false;: Skips running tests during the build. This is common for faster builds, especially in CI/CD, but tests are often run in a separate checks output (as seen in the flake.nix).\nstrictDeps = true;: Ensures that all dependencies are explicitly declared.\n# Sets the Helix runtime dir to the grammars env.HELIX_DEFAULT_RUNTIME = \"${runtimeDir}\"; # Sets the Helix runtime dir to the grammars env.HELIX_DEFAULT_RUNTIME = \"${runtimeDir}\"; env.HELIX_DEFAULT_RUNTIME: Tells Helix where to find its runtime files (including the Nix-managed grammars).\n# Get all the application stuff in the output directory. postInstall = '' mkdir -p $out/lib installShellCompletion ${./contrib/completion}/hx.{bash,fish,zsh} mkdir -p $out/share/{applications,icons/hicolor/{256x256,scalable}/apps} cp ${./contrib/Helix.desktop} $out/share/applications/Helix.desktop cp ${./logo.svg} $out/share/icons/hicolor/scalable/apps/helix.svg cp ${./contrib/helix.png} $out/share/icons/hicolor/256x256/apps/helix.png ''; postInstall: A shell script that runs after the main build is complete. This is used for installing additional files that are part of the Helix distribution but not directly built by Cargo.\nInstalls shell completion files (hx.bash, hx.fish, hx.zsh). This enables tab completion.\nInstalls desktop entry files (Helix.desktop) and icons (logo.svg, helix.png) for desktop integration for GUI environments.\nmeta.mainProgram = \"hx\"; }) meta.mainProgram: Specifies the primary executable provided by this package, allowing nix run to automatically execute hx.\nA lot going on in this derivation!\nMaking Actual Changes Locate the packages output section. It looks like this: packages = eachSystem (system: { inherit (pkgsFor.${system}) helix; /* The default Helix build. Uses the latest stable Rust toolchain, and unstable nixpkgs. The build inputs can be overridden with the following: packages.${system}.default.override { rustPlatform = newPlatform; }; Overriding a derivation attribute can be done as well: packages.${system}.default.overrideAttrs { buildType = \"debug\"; }; */ default = self.packages.${system}.helix; }); Modify the default package. The comments actually tell us exactly how to do this. We want to use overrideAttrs to change the buildType Change this line:\ndefault = self.packages.${system}.helix; To this:\ndefault = self.packages.${system}.helix.overrideAttrs { buildType = \"debug\"; }; This tells Nix to take the standard Helix package definition and override one of its internal attributes (buildType) to “debug” instead of “release”. Build the “Hacked” Helix: nix build Nix will now rebuild Helix, but this time, it will compile it in debug mode. You’ll likely notice the build takes a bit longer, and the resulting binary will be larger due to the included debugging symbols. Run the Debug Binary: ./result/bin/hx You’re now running your custom-built debug version of Helix! This is useful if you were, for example, attatching a debugger. This is a simple yet powerful “hack” that demonstrates how easily you can modify the behavior of a package defined within a Nix flake without changing the original source code or the upstream flake directly. You’re simply telling Nix how you’d like your version of the package to be built.\nAnother way to Modify Behavior Since we are already familiar with the structure and behavior of Helix’s flake.nix, we can leverage that understanding to create our own Nix flake. By analyzing how Helix organizes its inputs, outputs, and package definitions, we gain the confidence to modify and extend a flake’s functionality to suit our specific needs—whether that’s customizing builds, adding overlays, or integrating with home-manager.\nCreate a flake.nix in your own directory (outside the helix repo): { description = \"Customized Helix build with debug features\"; inputs = { helix.url = \"github:helix-editor/helix\"; nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\"; rust-overlay = { url = \"github:oxalica/rust-overlay\"; inputs.nixpkgs.follows = \"nixpkgs\"; }; }; outputs = { self, helix, nixpkgs, rust-overlay, }: let system = \"x86_64-linux\"; pkgs = import nixpkgs { system = system; overlays = [rust-overlay.overlay.overlays.default]; }; in { packages.${system}.default = helix.packages.${system}.helix.overrideAttrs (old: { buildType = \"debug\"; # Add additional cargo features cargoBuildFlags = (old.cargoBuildFlags or []) ++ [ \"--features\" \"tokio-console\" ]; # Inject custom RUSTFLAGS RUSTFLAGS = (old.RUSTFLAGS or \"\") + \" -C debuginfo=2 -C opt-level=1\"; }); }; } Check it:\nnix flake check warning: creating lock file '\"/home/jr/world/flake.lock\"': • Added input 'helix': 'github:helix-editor/helix/8961ae1dc66633ea6c9f761896cb0d885ae078ed?narHash=sha256-f14perPUk%2BH15GyGRbg0Akqhn3rxFnc6Ez5onqpzu6A%3D' (2025-05-29) • Added input 'helix/nixpkgs': 'github:nixos/nixpkgs/5135c59491985879812717f4c9fea69604e7f26f?narHash=sha256-Vr3Qi346M%2B8CjedtbyUevIGDZW8LcA1fTG0ugPY/Hic%3D' (2025-02-26) • Added input 'helix/rust-overlay': 'github:oxalica/rust-overlay/d342e8b5fd88421ff982f383c853f0fc78a847ab?narHash=sha256-3SdPQrZoa4odlScFDUHd4CUPQ/R1gtH4Mq9u8CBiK8M%3D' (2025-02-27) • Added input 'helix/rust-overlay/nixpkgs': follows 'helix/nixpkgs' • Added input 'nixpkgs': 'github:nixos/nixpkgs/96ec055edbe5ee227f28cdbc3f1ddf1df5965102?narHash=sha256-7doLyJBzCllvqX4gszYtmZUToxKvMUrg45EUWaUYmBg%3D' (2025-05-28) • Added input 'rust-overlay': 'github:oxalica/rust-overlay/405ef13a5b80a0a4d4fc87c83554423d80e5f929?narHash=sha256-k0nhPtkVDQkVJckRw6fGIeeDBktJf1BH0i8T48o7zkk%3D' (2025-05-30) • Added input 'rust-overlay/nixpkgs': follows 'nixpkgs' The nix flake check command will generate a flake.lock file if one doesn’t exist, and the warnings you see indicate that new inputs are being added and locked to specific versions for reproducibility. This is expected behavior for a new or modified flake. Inspect the outputs:\nnix flake show path:/home/jr/world?lastModified=1748612128\u0026narHash=sha256-WEYtptarRrrm0Jb/0PJ/b5VPqLkCk5iEenjbKYU4Xm8%3D └───packages └───x86_64-linux └───default: package 'helix-term' The └───packages line indicates that our flake exposes a top-level packages attribute.\n└───x86_64-linux: System architecture specificity\n└───default: package 'helix-term' Signifies that within the x86_64-linux packages, there’s a package named default. This is a special name that allows you to omit the package name when using commands like nix build.\npackage 'helix-term' This is the most direct confirmation of our “hack”. It tells us that our default package is helix-term. This confirms that our overrideAttrs in the packages.${system}.default section successfully targeted and modified the Helix editor package, which is internally named helix-term by the Helix flake.\nWhat This Does:\noverrideAttrs lets you change only parts of the derivation without rewriting everything.\nbuildType = \"debug\" enables debug builds.\ncargoBuildFlags adds extra features passed to Cargo, e.g., --features tokio-console\nRUSTFLAGS gives you even more control over compiler behavior, optimization levels, etc.\nRun It:\nnix run Or drop into the dev shell:\nnix develop (assuming you also wire in a devShells output) Adding the devShells output:\nSince we already have the helix flake as an input to our own flake.nix we can now forward or extend Helix’s devShells like this:\noutputs = { self, nixpkgs, helix, rust-overlay, ... }: { devShells = helix.devShells; }; Or if you want to pick a specific system:\noutputs = { self, nixpkgs, helix, rust-overlay ... }: let system = \"x86_64-linux\"; in { devShells.${system} = helix.devShells.${system}; }; Optional: Combine with your own devShell\nYou can also extend or merge it with your own shell like so:\noutputs = { self, nixpkgs, helix, rust-overlay, ... }: let system = \"x86_64-linux\"; pkgs = import nixpkgs { inherit system; }; in { devShells.${system} = { default = pkgs.mkShell { name = \"my-shell\"; inputsFrom = [ helix.devShells.${system}.default ]; buildInputs = [ pkgs.git ]; }; }; }; ","wordCount":"2883","inLanguage":"en","datePublished":"2025-05-30T19:23:32-04:00","dateModified":"2025-05-30T19:23:32-04:00","author":{"@type":"Person","name":"T Sawyer"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://tsawyer87.github.io/posts/hacking_the_helix_flake/"},"publisher":{"@type":"Organization","name":"NixOS Blog","logo":{"@type":"ImageObject","url":"https://tsawyer87.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tsawyer87.github.io/ accesskey=h title="NixOS Blog (Alt + H)">NixOS Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
<a href=/index.xml title="RSS Feed"><img src=/images/rss.png alt="RSS Feed" style=width:24px;height:24px></a></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">hacking_the_helix_flake</h1><div class=post-meta><span title='2025-05-30 19:23:32 -0400 EDT'>May 30, 2025</span>&nbsp;·&nbsp;T Sawyer</div></header><div class=post-content><ul><li><a href=#chapter-44>Chapter 4.4</a></li><li><a href=#understanding-the-helix-flake-and-modifying-its-behavior>Understanding the Helix Flake and Modifying its Behavior</a><ul><li><a href=#understanding-the-helix-flakenix>Understanding the Helix flake.nix</a></li><li><a href=#top-level-metadata>Top-Level Metadata</a></li><li><a href=#inputs>Inputs</a></li><li><a href=#outputs-function>Outputs Function</a></li><li><a href=#common-setup>Common Setup</a> -
<a href=#breaking-down-helixdefaultnix>Breaking Down <code>helix/default.nix</code></a> -
<a href=#making-actual-changes>Making Actual Changes</a> -
<a href=#another-way-to-modify-behavior>Another way to Modify Behavior</a></li></ul></li></ul><h1 id=understanding-the-helix-flake-and-modifying-its-behavior>Understanding the Helix Flake and Modifying its Behavior<a hidden class=anchor aria-hidden=true href=#understanding-the-helix-flake-and-modifying-its-behavior>#</a></h1><p>As we&rsquo;ve seen from previous examples, the helix editor repository includes a few
<code>.nix</code> files including a <code>flake.nix</code>. Their flake uses a lot of idiomatic Nix
code and advanced features. First I will break down their <code>flake.nix</code> and
<code>default.nix</code> to understand why they do certain things. And finally, we will
change the build to &ldquo;debug&rdquo; mode demonstrating how easily you can modify the
behavior of a package defined within a Nix flake without changing the original
source code or the upstream flake directly.</p><ol><li>Let&rsquo;s clone the Helix repository:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git clone https://github.com/helix-editor/helix.git
</span></span><span style=display:flex><span>cd helix
</span></span></code></pre></div><ol start=2><li>Enter the Development Shell:</li></ol><p>The Helix project&rsquo;s <code>flake.nix</code> includes a <code>devShells.default</code> output,
specifically designed for development.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>nix develop
</span></span></code></pre></div><ol start=3><li>You&rsquo;re now in a fully configured development environment:</li></ol><ul><li>When you run <code>nix develop</code>, Nix builds and drops you into a shell environment
with all the dependencies specified in <code>devShells.default</code>. This means you
don’t have to manually install or manage tools like Rust, Cargo, or Clang—it’s
all handled declaratively through Nix.</li></ul><p>You can now build and run the project using its standard tooling:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cargo build
</span></span><span style=display:flex><span>cargo run
</span></span></code></pre></div><ol start=4><li>Making Changes and Testing Them</li></ol><p>Since you&rsquo;re in a reproducible environment, you can confidently hack on the
project without worrying about your system setup. Try modifying some code in
<code>helix</code> and rebuilding with Cargo. The Nix shell ensures consistency for every
contributor or device you work on.</p><ol start=5><li>Run Just the Binary</li></ol><p>If you only want to run the compiled program without entering the shell, use the
nix run command:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>nix run
</span></span></code></pre></div><p>This builds and runs the default package defined by the flake. In the case of
Helix, this launches the <code>hx</code> editor directly.</p><ol start=6><li>Build Without Running</li></ol><p>To just build the project and get the path to the output binary:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>nix build
</span></span></code></pre></div><p>You’ll find the compiled binary under <code>./result/bin</code>.</p><ol start=7><li>Pinning and Reproducing</li></ol><p>Because the project uses a flake, you can ensure full reproducibility by pinning
the inputs. For example, you can clone with &ndash;recurse-submodules and copy the
flake.lock to ensure you&rsquo;re using the same dependency versions as upstream. This
is great for debugging or sharing exact builds.</p><p>✅ Recap:</p><p>With flakes, projects like Helix provide everything you need for development and
running in a single flake.nix. You can nix develop to get started hacking, nix
run to quickly try it out, and nix build to produce binaries—all without
installing or polluting your system.</p><h2 id=understanding-the-helix-flakenix>Understanding the Helix flake.nix<a hidden class=anchor aria-hidden=true href=#understanding-the-helix-flakenix>#</a></h2><p>The helix flake is full of idiomatic Nix code and displays some of the more
advanced things a flake can provide:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>{
</span></span><span style=display:flex><span>  description <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;A post-modern text editor.&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  inputs <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    nixpkgs<span style=color:#f92672>.</span>url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;github:nixos/nixpkgs/nixos-unstable&#34;</span>;
</span></span><span style=display:flex><span>    rust-overlay <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>      url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;github:oxalica/rust-overlay&#34;</span>;
</span></span><span style=display:flex><span>      inputs<span style=color:#f92672>.</span>nixpkgs<span style=color:#f92672>.</span>follows <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;nixpkgs&#34;</span>;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  outputs <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    self<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>    nixpkgs<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>    rust-overlay<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>  }: <span style=color:#66d9ef>let</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>inherit</span> (nixpkgs) lib;
</span></span><span style=display:flex><span>    systems <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>      <span style=color:#e6db74>&#34;x86_64-linux&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#e6db74>&#34;aarch64-linux&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#e6db74>&#34;x86_64-darwin&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#e6db74>&#34;aarch64-darwin&#34;</span>
</span></span><span style=display:flex><span>    ];
</span></span><span style=display:flex><span>    eachSystem <span style=color:#f92672>=</span> lib<span style=color:#f92672>.</span>genAttrs systems;
</span></span><span style=display:flex><span>    pkgsFor <span style=color:#f92672>=</span> eachSystem (system:
</span></span><span style=display:flex><span>      <span style=color:#f92672>import</span> nixpkgs {
</span></span><span style=display:flex><span>        localSystem<span style=color:#f92672>.</span>system <span style=color:#f92672>=</span> system;
</span></span><span style=display:flex><span>        overlays <span style=color:#f92672>=</span> [(<span style=color:#f92672>import</span> rust-overlay) self<span style=color:#f92672>.</span>overlays<span style=color:#f92672>.</span>helix];
</span></span><span style=display:flex><span>      });
</span></span><span style=display:flex><span>    gitRev <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>rev or self<span style=color:#f92672>.</span>dirtyRev or <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>in</span> {
</span></span><span style=display:flex><span>    packages <span style=color:#f92672>=</span> eachSystem (system: {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>inherit</span> (pkgsFor<span style=color:#f92672>.</span><span style=color:#e6db74>${</span>system<span style=color:#e6db74>}</span>) helix;
</span></span><span style=display:flex><span>      <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>      The default Helix build. Uses the latest stable Rust toolchain, and unstable
</span></span></span><span style=display:flex><span><span style=color:#75715e>      nixpkgs.
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>      The build inputs can be overridden with the following:
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>      packages.${system}.default.override { rustPlatform = newPlatform; };
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>      Overriding a derivation attribute can be done as well:
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>      packages.${system}.default.overrideAttrs { buildType = &#34;debug&#34;; };
</span></span></span><span style=display:flex><span><span style=color:#75715e>      */</span>
</span></span><span style=display:flex><span>      default <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>packages<span style=color:#f92672>.</span><span style=color:#e6db74>${</span>system<span style=color:#e6db74>}</span><span style=color:#f92672>.</span>helix;
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>    checks <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>      lib<span style=color:#f92672>.</span>mapAttrs (system: pkgs: <span style=color:#66d9ef>let</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Get Helix&#39;s MSRV toolchain to build with by default.</span>
</span></span><span style=display:flex><span>        msrvToolchain <span style=color:#f92672>=</span> pkgs<span style=color:#f92672>.</span>pkgsBuildHost<span style=color:#f92672>.</span>rust-bin<span style=color:#f92672>.</span>fromRustupToolchainFile <span style=color:#e6db74>./rust-toolchain.toml</span>;
</span></span><span style=display:flex><span>        msrvPlatform <span style=color:#f92672>=</span> pkgs<span style=color:#f92672>.</span>makeRustPlatform {
</span></span><span style=display:flex><span>          cargo <span style=color:#f92672>=</span> msrvToolchain;
</span></span><span style=display:flex><span>          rustc <span style=color:#f92672>=</span> msrvToolchain;
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>in</span> {
</span></span><span style=display:flex><span>        helix <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>packages<span style=color:#f92672>.</span><span style=color:#e6db74>${</span>system<span style=color:#e6db74>}</span><span style=color:#f92672>.</span>helix<span style=color:#f92672>.</span>override {
</span></span><span style=display:flex><span>          rustPlatform <span style=color:#f92672>=</span> msrvPlatform;
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>      })
</span></span><span style=display:flex><span>      pkgsFor;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Devshell behavior is preserved.</span>
</span></span><span style=display:flex><span>    devShells <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>      lib<span style=color:#f92672>.</span>mapAttrs (system: pkgs: {
</span></span><span style=display:flex><span>        default <span style=color:#f92672>=</span> <span style=color:#66d9ef>let</span>
</span></span><span style=display:flex><span>          commonRustFlagsEnv <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;-C link-arg=-fuse-ld=lld -C target-cpu=native --cfg tokio_unstable&#34;</span>;
</span></span><span style=display:flex><span>          platformRustFlagsEnv <span style=color:#f92672>=</span> lib<span style=color:#f92672>.</span>optionalString pkgs<span style=color:#f92672>.</span>stdenv<span style=color:#f92672>.</span>isLinux <span style=color:#e6db74>&#34;-Clink-arg=-Wl,--no-rosegment&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>          pkgs<span style=color:#f92672>.</span>mkShell {
</span></span><span style=display:flex><span>            inputsFrom <span style=color:#f92672>=</span> [self<span style=color:#f92672>.</span>checks<span style=color:#f92672>.</span><span style=color:#e6db74>${</span>system<span style=color:#e6db74>}</span><span style=color:#f92672>.</span>helix];
</span></span><span style=display:flex><span>            nativeBuildInputs <span style=color:#f92672>=</span> <span style=color:#66d9ef>with</span> pkgs;
</span></span><span style=display:flex><span>              [
</span></span><span style=display:flex><span>                lld
</span></span><span style=display:flex><span>                cargo-flamegraph
</span></span><span style=display:flex><span>                rust-bin<span style=color:#f92672>.</span>nightly<span style=color:#f92672>.</span>latest<span style=color:#f92672>.</span>rust-analyzer
</span></span><span style=display:flex><span>              ]
</span></span><span style=display:flex><span>              <span style=color:#f92672>++</span> (lib<span style=color:#f92672>.</span>optional (stdenv<span style=color:#f92672>.</span>isx86_64 <span style=color:#f92672>&amp;&amp;</span> stdenv<span style=color:#f92672>.</span>isLinux) cargo-tarpaulin)
</span></span><span style=display:flex><span>              <span style=color:#f92672>++</span> (lib<span style=color:#f92672>.</span>optional stdenv<span style=color:#f92672>.</span>isLinux lldb)
</span></span><span style=display:flex><span>              <span style=color:#f92672>++</span> (lib<span style=color:#f92672>.</span>optional stdenv<span style=color:#f92672>.</span>isDarwin darwin<span style=color:#f92672>.</span>apple_sdk<span style=color:#f92672>.</span>frameworks<span style=color:#f92672>.</span>CoreFoundation);
</span></span><span style=display:flex><span>            shellHook <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>              export RUST_BACKTRACE=&#34;1&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>              export RUSTFLAGS=&#34;</span><span style=color:#ae81ff>&#39;&#39;$</span><span style=color:#e6db74>{RUSTFLAGS:-&#34;&#34;} </span><span style=color:#e6db74>${</span>commonRustFlagsEnv<span style=color:#e6db74>}</span><span style=color:#e6db74> </span><span style=color:#e6db74>${</span>platformRustFlagsEnv<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            &#39;&#39;</span>;
</span></span><span style=display:flex><span>          };
</span></span><span style=display:flex><span>      })
</span></span><span style=display:flex><span>      pkgsFor;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    overlays <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>      helix <span style=color:#f92672>=</span> final: prev: {
</span></span><span style=display:flex><span>        helix <span style=color:#f92672>=</span> final<span style=color:#f92672>.</span>callPackage <span style=color:#e6db74>./default.nix</span> {<span style=color:#66d9ef>inherit</span> gitRev;};
</span></span><span style=display:flex><span>      };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      default <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>overlays<span style=color:#f92672>.</span>helix;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>  nixConfig <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    extra-substituters <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#34;https://helix.cachix.org&#34;</span>];
</span></span><span style=display:flex><span>    extra-trusted-public-keys <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#34;helix.cachix.org-1:ejp9KQpR1FBI2onstMQ34yogDm4OgU2ru6lIwPvuCVs=&#34;</span>];
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=top-level-metadata>Top-Level Metadata<a hidden class=anchor aria-hidden=true href=#top-level-metadata>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>{
</span></span><span style=display:flex><span>  description <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;A post-modern text editor.&#34;</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>This sets a human-readable description for the flake.</li></ul><h2 id=inputs>Inputs<a hidden class=anchor aria-hidden=true href=#inputs>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>inputs <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  nixpkgs<span style=color:#f92672>.</span>url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;github:nixos/nixpkgs/nixos-unstable&#34;</span>;
</span></span><span style=display:flex><span>  rust-overlay <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;github:oxalica/rust-overlay&#34;</span>;
</span></span><span style=display:flex><span>    inputs<span style=color:#f92672>.</span>nixpkgs<span style=color:#f92672>.</span>follows <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;nixpkgs&#34;</span>;
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><ul><li><p><code>nixpkgs</code>: Uses the <code>nixos-unstable</code> branch of the Nixpkgs repository.</p></li><li><p><code>rust-overlay</code>: follows the same <code>nixpkgs</code>, ensuring compatibility between
inputs.</p></li></ul><h2 id=outputs-function>Outputs Function<a hidden class=anchor aria-hidden=true href=#outputs-function>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>outputs <span style=color:#f92672>=</span> { self<span style=color:#f92672>,</span> nixpkgs<span style=color:#f92672>,</span> rust-overlay<span style=color:#f92672>,</span> <span style=color:#f92672>...</span> }:
</span></span></code></pre></div><ul><li>This defines what this flake exports, including <code>packages</code>, <code>devShells</code>, etc.</li></ul><h2 id=common-setup>Common Setup<a hidden class=anchor aria-hidden=true href=#common-setup>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span><span style=color:#66d9ef>let</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>inherit</span> (nixpkgs) lib;
</span></span><span style=display:flex><span>  systems <span style=color:#f92672>=</span> [ <span style=color:#f92672>...</span> ];
</span></span><span style=display:flex><span>  eachSystem <span style=color:#f92672>=</span> lib<span style=color:#f92672>.</span>genAttrs systems;
</span></span></code></pre></div><ul><li><p><code>systems</code>: A list of the supported systems</p></li><li><p><code>eachSystem</code>: A Helper to map over all platforms.</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>  pkgsFor <span style=color:#f92672>=</span> eachSystem (system:
</span></span><span style=display:flex><span>    <span style=color:#f92672>import</span> nixpkgs {
</span></span><span style=display:flex><span>      localSystem<span style=color:#f92672>.</span>system <span style=color:#f92672>=</span> system;
</span></span><span style=display:flex><span>      overlays <span style=color:#f92672>=</span> [(<span style=color:#f92672>import</span> rust-overlay) self<span style=color:#f92672>.</span>overlays<span style=color:#f92672>.</span>helix];
</span></span><span style=display:flex><span>    });
</span></span></code></pre></div><ul><li>This imports <code>nixpkgs</code> for each system and applies overlays</li></ul><p>📦 <code>packages</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>packages <span style=color:#f92672>=</span> eachSystem (system: {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>inherit</span> (pkgsFor<span style=color:#f92672>.</span><span style=color:#e6db74>${</span>system<span style=color:#e6db74>}</span>) helix;
</span></span><span style=display:flex><span>  default <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>packages<span style=color:#f92672>.</span><span style=color:#e6db74>${</span>system<span style=color:#e6db74>}</span><span style=color:#f92672>.</span>helix;
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><ul><li>For each platform:<ul><li><p>Includes a <code>helix</code> package (defined in <code>./default.nix</code>)</p></li><li><p>Sets <code>default</code> to <code>helix</code> (used by <code>nix build</code>, <code>nix run</code>)</p></li></ul></li></ul><p>Let&rsquo;s look at the helix <code>default.nix</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>{
</span></span><span style=display:flex><span>  lib<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>  rustPlatform<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>  callPackage<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>  runCommand<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>  installShellFiles<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>  git<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>  gitRev <span style=color:#f92672>?</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>  grammarOverlays <span style=color:#f92672>?</span> []<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>  includeGrammarIf <span style=color:#f92672>?</span> _: <span style=color:#66d9ef>true</span><span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>}: <span style=color:#66d9ef>let</span>
</span></span><span style=display:flex><span>  fs <span style=color:#f92672>=</span> lib<span style=color:#f92672>.</span>fileset;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  src <span style=color:#f92672>=</span> fs<span style=color:#f92672>.</span>difference (fs<span style=color:#f92672>.</span>gitTracked <span style=color:#e6db74>./.</span>) (fs<span style=color:#f92672>.</span>unions [
</span></span><span style=display:flex><span>    <span style=color:#e6db74>./.envrc</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>./rustfmt.toml</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>./screenshot.png</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>./book</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>./docs</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>./runtime</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>./flake.lock</span>
</span></span><span style=display:flex><span>    (fs<span style=color:#f92672>.</span>fileFilter (file: lib<span style=color:#f92672>.</span>strings<span style=color:#f92672>.</span>hasInfix <span style=color:#e6db74>&#34;.git&#34;</span> file<span style=color:#f92672>.</span>name) <span style=color:#e6db74>./.</span>)
</span></span><span style=display:flex><span>    (fs<span style=color:#f92672>.</span>fileFilter (file: file<span style=color:#f92672>.</span>hasExt <span style=color:#e6db74>&#34;svg&#34;</span>) <span style=color:#e6db74>./.</span>)
</span></span><span style=display:flex><span>    (fs<span style=color:#f92672>.</span>fileFilter (file: file<span style=color:#f92672>.</span>hasExt <span style=color:#e6db74>&#34;md&#34;</span>) <span style=color:#e6db74>./.</span>)
</span></span><span style=display:flex><span>    (fs<span style=color:#f92672>.</span>fileFilter (file: file<span style=color:#f92672>.</span>hasExt <span style=color:#e6db74>&#34;nix&#34;</span>) <span style=color:#e6db74>./.</span>)
</span></span><span style=display:flex><span>  ]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># Next we actually need to build the grammars and the runtime directory</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># that they reside in. It is built by calling the derivation in the</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># grammars.nix file, then taking the runtime directory in the git repo</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># and hooking symlinks up to it.</span>
</span></span><span style=display:flex><span>  grammars <span style=color:#f92672>=</span> callPackage <span style=color:#e6db74>./grammars.nix</span> {<span style=color:#66d9ef>inherit</span> grammarOverlays includeGrammarIf;};
</span></span><span style=display:flex><span>  runtimeDir <span style=color:#f92672>=</span> runCommand <span style=color:#e6db74>&#34;helix-runtime&#34;</span> {} <span style=color:#e6db74>&#39;&#39;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    mkdir -p $out
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    ln -s </span><span style=color:#e6db74>${</span><span style=color:#e6db74>./runtime</span><span style=color:#e6db74>}</span><span style=color:#e6db74>/* $out
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    rm -r $out/grammars
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    ln -s </span><span style=color:#e6db74>${</span>grammars<span style=color:#e6db74>}</span><span style=color:#e6db74> $out/grammars
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  &#39;&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  rustPlatform<span style=color:#f92672>.</span>buildRustPackage (self: {
</span></span><span style=display:flex><span>    cargoLock <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>      lockFile <span style=color:#f92672>=</span> <span style=color:#e6db74>./Cargo.lock</span>;
</span></span><span style=display:flex><span>      <span style=color:#75715e># This is not allowed in nixpkgs but is very convenient here: it allows us to</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e># avoid specifying `outputHashes` here for any git dependencies we might take</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e># on temporarily.</span>
</span></span><span style=display:flex><span>      allowBuiltinFetchGit <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    nativeBuildInputs <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>      installShellFiles
</span></span><span style=display:flex><span>      git
</span></span><span style=display:flex><span>    ];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    buildType <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;release&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    name <span style=color:#f92672>=</span> <span style=color:#66d9ef>with</span> builtins; (fromTOML (readFile <span style=color:#e6db74>./helix-term/Cargo.toml</span>))<span style=color:#f92672>.</span>package<span style=color:#f92672>.</span>name;
</span></span><span style=display:flex><span>    src <span style=color:#f92672>=</span> fs<span style=color:#f92672>.</span>toSource {
</span></span><span style=display:flex><span>      root <span style=color:#f92672>=</span> <span style=color:#e6db74>./.</span>;
</span></span><span style=display:flex><span>      fileset <span style=color:#f92672>=</span> src;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Helix attempts to reach out to the network and get the grammars. Nix doesn&#39;t allow this.</span>
</span></span><span style=display:flex><span>    HELIX_DISABLE_AUTO_GRAMMAR_BUILD <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;1&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># So Helix knows what rev it is.</span>
</span></span><span style=display:flex><span>    HELIX_NIX_BUILD_REV <span style=color:#f92672>=</span> gitRev;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    doCheck <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    strictDeps <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Sets the Helix runtime dir to the grammars</span>
</span></span><span style=display:flex><span>    env<span style=color:#f92672>.</span>HELIX_DEFAULT_RUNTIME <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>runtimeDir<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Get all the application stuff in the output directory.</span>
</span></span><span style=display:flex><span>    postInstall <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      mkdir -p $out/lib
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      installShellCompletion </span><span style=color:#e6db74>${</span><span style=color:#e6db74>./contrib/completion</span><span style=color:#e6db74>}</span><span style=color:#e6db74>/hx.{bash,fish,zsh}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      mkdir -p $out/share/{applications,icons/hicolor/{256x256,scalable}/apps}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      cp </span><span style=color:#e6db74>${</span><span style=color:#e6db74>./contrib/Helix.desktop</span><span style=color:#e6db74>}</span><span style=color:#e6db74> $out/share/applications/Helix.desktop
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      cp </span><span style=color:#e6db74>${</span><span style=color:#e6db74>./logo.svg</span><span style=color:#e6db74>}</span><span style=color:#e6db74> $out/share/icons/hicolor/scalable/apps/helix.svg
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      cp </span><span style=color:#e6db74>${</span><span style=color:#e6db74>./contrib/helix.png</span><span style=color:#e6db74>}</span><span style=color:#e6db74> $out/share/icons/hicolor/256x256/apps/helix.png
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#39;&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    meta<span style=color:#f92672>.</span>mainProgram <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;hx&#34;</span>;
</span></span><span style=display:flex><span>  })
</span></span></code></pre></div><h3 id=breaking-down-helixdefaultnix>Breaking Down <code>helix/default.nix</code><a hidden class=anchor aria-hidden=true href=#breaking-down-helixdefaultnix>#</a></h3><p>This <code>default.nix</code> file is a Nix derivation that defines how to build the Helix
editor itself. It&rsquo;s designed to be called by the main <code>flake.nix</code> as part of its
<code>packages</code> output.</p><p>Here&rsquo;s a breakdown of its components:</p><ol><li><strong>Function Arguments</strong>:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>{
</span></span><span style=display:flex><span>  lib<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>  rustPlatform<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>  callPackage<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>  runCommand<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>  installShellFiles<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>  git<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>  gitRev <span style=color:#f92672>?</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>  grammarOverlays <span style=color:#f92672>?</span> []<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>  includeGrammarIf <span style=color:#f92672>?</span> _: <span style=color:#66d9ef>true</span><span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>}:
</span></span></code></pre></div><p><code>lib</code>: The Nixpkgs <code>lib</code> (library) functions, essential for common operations
like <code>fileset</code> and <code>strings</code>.</p><p><code>rustPlatform</code>: A helper function from Nixpkgs specifically for building Rust
projects. It provides a <code>buildRustPackage</code> function, which simplifies the
process significantly.</p><p><code>callPackage</code>: A Nixpkgs function used to instantiate a Nix expression (like
<code>grammars.nix</code>) with its dependencies automatically supplied from the current
Nix environment.</p><p><code>runCommand</code>: A Nixpkgs primitive that creates a derivation by running a shell
command. It&rsquo;s used here to construct the <code>runtimeDir</code>.</p><p><code>installShellFiles</code>: A utility from Nixpkgs for installing shell completion
files.</p><p><code>git</code>: The Git package, needed for determining the <code>gitRev</code>.</p><p><code>gitRev ? null</code>: The Git revision of the Helix repository. It&rsquo;s an optional
argument, defaulting to null. This is passed in from the main <code>flake.nix</code>.</p><p><code>grammarOverlays ? []</code>: An optional list of overlays for grammars, allowing
customization.</p><p><code>includeGrammarIf ? _: true</code>: An optional function to control which grammars are
included.</p><ol start=2><li><strong>Local Variables</strong> (<code>let ... in</code>)</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span><span style=color:#66d9ef>let</span>
</span></span><span style=display:flex><span>  fs <span style=color:#f92672>=</span> lib<span style=color:#f92672>.</span>fileset;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  src <span style=color:#f92672>=</span> fs<span style=color:#f92672>.</span>difference (fs<span style=color:#f92672>.</span>gitTracked <span style=color:#e6db74>./.</span>) (fs<span style=color:#f92672>.</span>unions [
</span></span><span style=display:flex><span>    <span style=color:#e6db74>./.envrc</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>./rustfmt.toml</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>./screenshot.png</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>./book</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>./docs</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>./runtime</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>./flake.lock</span>
</span></span><span style=display:flex><span>    (fs<span style=color:#f92672>.</span>fileFilter (file: lib<span style=color:#f92672>.</span>strings<span style=color:#f92672>.</span>hasInfix <span style=color:#e6db74>&#34;.git&#34;</span> file<span style=color:#f92672>.</span>name) <span style=color:#e6db74>./.</span>)
</span></span><span style=display:flex><span>    (fs<span style=color:#f92672>.</span>fileFilter (file: file<span style=color:#f92672>.</span>hasExt <span style=color:#e6db74>&#34;svg&#34;</span>) <span style=color:#e6db74>./.</span>)
</span></span><span style=display:flex><span>    (fs<span style=color:#f92672>.</span>fileFilter (file: file<span style=color:#f92672>.</span>hasExt <span style=color:#e6db74>&#34;md&#34;</span>) <span style=color:#e6db74>./.</span>)
</span></span><span style=display:flex><span>    (fs<span style=color:#f92672>.</span>fileFilter (file: file<span style=color:#f92672>.</span>hasExt <span style=color:#e6db74>&#34;nix&#34;</span>) <span style=color:#e6db74>./.</span>)
</span></span><span style=display:flex><span>  ]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  grammars <span style=color:#f92672>=</span> callPackage <span style=color:#e6db74>./grammars.nix</span> { <span style=color:#66d9ef>inherit</span> grammarOverlays includeGrammarIf; };
</span></span><span style=display:flex><span>  runtimeDir <span style=color:#f92672>=</span> runCommand <span style=color:#e6db74>&#34;helix-runtime&#34;</span> {} <span style=color:#e6db74>&#39;&#39;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    mkdir -p $out
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    ln -s </span><span style=color:#e6db74>${</span><span style=color:#e6db74>./runtime</span><span style=color:#e6db74>}</span><span style=color:#e6db74>/* $out
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    rm -r $out/grammars
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    ln -s </span><span style=color:#e6db74>${</span>grammars<span style=color:#e6db74>}</span><span style=color:#e6db74> $out/grammars
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  &#39;&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>in</span>
</span></span></code></pre></div><p><code>fs = lib.fileset;</code>: Aliases <code>lib.fileset</code> for convenient file set operations.</p><p><code>src</code>: This is a crucial part. It defines the source files that will be used to
build Helix by:</p><ul><li><p>Taking all Git-tracked files in the current directory (<code>fs.gitTracked ./.</code>).</p></li><li><p>Excluding configuration files (e.g., .envrc, flake.lock), documentation (.md),
images (.svg), and Nix files (.nix) using fs.difference and fs.unions. This
ensures a clean build input, reducing Nix store size and avoiding unnecessary
rebuilds.</p></li><li><p><code>grammars</code>: Builds syntax grammars by calling <code>grammars.nix</code>, passing
<code>grammarOverlays</code> (for customizing grammar builds) and <code>includeGrammarIf</code> (a
filter for selecting grammars).</p></li><li><p><code>runtimeDir</code>: Creates a runtime directory for Helix by:</p><ul><li><p>Symlinking the <code>runtime</code> directory from the source.</p></li><li><p>Replacing the <code>grammars</code> subdirectory with a symlink to the <code>grammars</code>
derivation, ensuring Helix uses Nix-managed grammars.</p></li></ul></li></ul><ol start=3><li><strong>The Build Derivation</strong> (<code>rustPlatform.buildRustPackage</code>)</li></ol><p>The core of this <code>default.nix</code> is the <code>rustPlatform.buildRustPackage</code> call,
which is a specialized builder for Rust projects:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>in
</span></span><span style=display:flex><span>  rustPlatform<span style=color:#f92672>.</span>buildRustPackage (self: {
</span></span><span style=display:flex><span>    cargoLock <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>      lockFile <span style=color:#f92672>=</span> <span style=color:#e6db74>./Cargo.lock</span>;
</span></span><span style=display:flex><span>      <span style=color:#75715e># ... comments ...</span>
</span></span><span style=display:flex><span>      allowBuiltinFetchGit <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    };
</span></span></code></pre></div><p><code>cargoLock</code>: Specifies how Cargo dependencies are handled.</p><p><code>lockFile = ./Cargo.lock;</code> Points to the <code>Cargo.lock</code> file for reproducible
builds.</p><p><code>allowBuiltinFetchGit = true</code>: Allows Cargo to fetch Git dependencies directly
from repositories specified in <code>Cargo.lock</code>. This is discouraged in Nixpkgs
because it can break build reproducibility, but it’s used here for convenience
during development, eliminating the need to manually specify <code>outputHashes</code> for
Git dependencies.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>nativeBuildInputs <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>      installShellFiles
</span></span><span style=display:flex><span>      git
</span></span><span style=display:flex><span>    ];
</span></span></code></pre></div><p><code>nativeBuildInputs</code>: Are tools needed during the build process but not
necessarily at runtime.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>buildType <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;release&#34;</span>;
</span></span></code></pre></div><p><code>buildType</code>: Specifies that Helix should be built in &ldquo;release&rdquo; mode (optimized).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>name <span style=color:#f92672>=</span> <span style=color:#66d9ef>with</span> builtins; (fromTOML (readFile <span style=color:#e6db74>./helix-term/Cargo.toml</span>))<span style=color:#f92672>.</span>package<span style=color:#f92672>.</span>name;
</span></span><span style=display:flex><span>    src <span style=color:#f92672>=</span> fs<span style=color:#f92672>.</span>toSource {
</span></span><span style=display:flex><span>      root <span style=color:#f92672>=</span> <span style=color:#e6db74>./.</span>;
</span></span><span style=display:flex><span>      fileset <span style=color:#f92672>=</span> src;
</span></span><span style=display:flex><span>    };
</span></span></code></pre></div><p><code>name</code>: Dynamically sets the package name by reading it from the <code>Cargo.toml</code>
file.</p><p><code>src</code>: Uses the <code>src</code> file set defined earlier as the source for the build.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span><span style=color:#75715e># Helix attempts to reach out to the network and get the grammars. Nix doesn&#39;t allow this.</span>
</span></span><span style=display:flex><span>    HELIX_DISABLE_AUTO_GRAMMAR_BUILD <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;1&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># So Helix knows what rev it is.</span>
</span></span><span style=display:flex><span>    HELIX_NIX_BUILD_REV <span style=color:#f92672>=</span> gitRev;
</span></span></code></pre></div><p><strong>Environment Variables</strong>: Sets environment variables that Helix uses.</p><p><code>HELIX_DISABLE_AUTO_GRAMMAR_BUILD = "1"</code>: Prevents Helix from downloading
grammars during the build, as Nix’s sandboxed environment disallows network
access. Instead, grammars are provided via the <code>runtimeDir</code> derivation.</p><p><code>HELIX_NIX_BUILD_REV = gitRev</code>: Embeds the specified Git revision (or <code>null</code> if
unspecified) into the Helix binary, allowing Helix to display its version or
commit hash.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span> doCheck <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    strictDeps <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span></code></pre></div><p><code>doCheck = false;</code>: Skips running tests during the build. This is common for
faster builds, especially in CI/CD, but tests are often run in a separate
<code>checks</code> output (as seen in the <code>flake.nix</code>).</p><p><code>strictDeps = true;</code>: Ensures that all dependencies are explicitly declared.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>    <span style=color:#75715e># Sets the Helix runtime dir to the grammars</span>
</span></span><span style=display:flex><span>    env<span style=color:#f92672>.</span>HELIX_DEFAULT_RUNTIME <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>runtimeDir<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>;
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>    <span style=color:#75715e># Sets the Helix runtime dir to the grammars</span>
</span></span><span style=display:flex><span>    env<span style=color:#f92672>.</span>HELIX_DEFAULT_RUNTIME <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>runtimeDir<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>;
</span></span></code></pre></div><p><code>env.HELIX_DEFAULT_RUNTIME</code>: Tells Helix where to find its runtime files
(including the Nix-managed grammars).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Get all the application stuff in the output directory.</span>
</span></span><span style=display:flex><span>    postInstall <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      mkdir -p $out/lib
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      installShellCompletion </span><span style=color:#e6db74>${</span><span style=color:#e6db74>./contrib/completion</span><span style=color:#e6db74>}</span><span style=color:#e6db74>/hx.{bash,fish,zsh}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      mkdir -p $out/share/{applications,icons/hicolor/{256x256,scalable}/apps}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      cp </span><span style=color:#e6db74>${</span><span style=color:#e6db74>./contrib/Helix.desktop</span><span style=color:#e6db74>}</span><span style=color:#e6db74> $out/share/applications/Helix.desktop
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      cp </span><span style=color:#e6db74>${</span><span style=color:#e6db74>./logo.svg</span><span style=color:#e6db74>}</span><span style=color:#e6db74> $out/share/icons/hicolor/scalable/apps/helix.svg
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      cp </span><span style=color:#e6db74>${</span><span style=color:#e6db74>./contrib/helix.png</span><span style=color:#e6db74>}</span><span style=color:#e6db74> $out/share/icons/hicolor/256x256/apps/helix.png
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#39;&#39;</span>;
</span></span></code></pre></div><p><code>postInstall</code>: A shell script that runs after the main build is complete. This
is used for installing additional files that are part of the Helix distribution
but not directly built by Cargo.</p><p>Installs shell completion files (<code>hx.bash</code>, <code>hx.fish</code>, <code>hx.zsh</code>). This enables
tab completion.</p><p>Installs desktop entry files (<code>Helix.desktop</code>) and icons (<code>logo.svg</code>,
<code>helix.png</code>) for desktop integration for GUI environments.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>
</span></span><span style=display:flex><span>    meta<span style=color:#f92672>.</span>mainProgram <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;hx&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>})</span>
</span></span></code></pre></div><p><code>meta.mainProgram</code>: Specifies the primary executable provided by this package,
allowing <code>nix run</code> to automatically execute <code>hx</code>.</p><p>A lot going on in this derivation!</p><h3 id=making-actual-changes>Making Actual Changes<a hidden class=anchor aria-hidden=true href=#making-actual-changes>#</a></h3><ol><li>Locate the <code>packages</code> output section. It looks like this:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>packages <span style=color:#f92672>=</span> eachSystem (system: {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>inherit</span> (pkgsFor<span style=color:#f92672>.</span><span style=color:#e6db74>${</span>system<span style=color:#e6db74>}</span>) helix;
</span></span><span style=display:flex><span>      <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>      The default Helix build. Uses the latest stable Rust toolchain, and unstable
</span></span></span><span style=display:flex><span><span style=color:#75715e>      nixpkgs.
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>      The build inputs can be overridden with the following:
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>      packages.${system}.default.override { rustPlatform = newPlatform; };
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>      Overriding a derivation attribute can be done as well:
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>      packages.${system}.default.overrideAttrs { buildType = &#34;debug&#34;; };
</span></span></span><span style=display:flex><span><span style=color:#75715e>      */</span>
</span></span><span style=display:flex><span>      default <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>packages<span style=color:#f92672>.</span><span style=color:#e6db74>${</span>system<span style=color:#e6db74>}</span><span style=color:#f92672>.</span>helix;
</span></span><span style=display:flex><span>    });
</span></span></code></pre></div><ol start=2><li>Modify the <code>default</code> package. The comments actually tell us exactly how to do
this. We want to use <code>overrideAttrs</code> to change the <code>buildType</code></li></ol><p>Change this line:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>default <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>packages<span style=color:#f92672>.</span><span style=color:#e6db74>${</span>system<span style=color:#e6db74>}</span><span style=color:#f92672>.</span>helix;
</span></span></code></pre></div><p>To this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>default <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>packages<span style=color:#f92672>.</span><span style=color:#e6db74>${</span>system<span style=color:#e6db74>}</span><span style=color:#f92672>.</span>helix<span style=color:#f92672>.</span>overrideAttrs { buildType <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;debug&#34;</span>; };
</span></span></code></pre></div><ul><li>This tells Nix to take the standard Helix package definition and override one
of its internal attributes (<code>buildType</code>) to &ldquo;debug&rdquo; instead of &ldquo;release&rdquo;.</li></ul><ol start=3><li>Build the &ldquo;Hacked&rdquo; Helix:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>nix build
</span></span></code></pre></div><ul><li>Nix will now rebuild Helix, but this time, it will compile it in debug mode.
You&rsquo;ll likely notice the build takes a bit longer, and the resulting binary
will be larger due to the included debugging symbols.</li></ul><ol start=4><li>Run the Debug Binary:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>./result/bin/hx
</span></span></code></pre></div><ul><li>You&rsquo;re now running your custom-built debug version of Helix! This is useful if
you were, for example, attatching a debugger.</li></ul><p>This is a simple yet powerful &ldquo;hack&rdquo; that demonstrates how easily you can modify
the behavior of a package defined within a Nix flake without changing the
original source code or the upstream flake directly. You&rsquo;re simply telling Nix
how you&rsquo;d like your version of the package to be built.</p><h3 id=another-way-to-modify-behavior>Another way to Modify Behavior<a hidden class=anchor aria-hidden=true href=#another-way-to-modify-behavior>#</a></h3><p>Since we are already familiar with the structure and behavior of Helix’s
<code>flake.nix</code>, we can leverage that understanding to create our own Nix flake. By
analyzing how Helix organizes its <code>inputs</code>, <code>outputs</code>, and package definitions,
we gain the confidence to modify and extend a flake’s functionality to suit our
specific needs—whether that’s customizing builds, adding overlays, or
integrating with home-manager.</p><ol><li>Create a <code>flake.nix</code> in your own directory (outside the helix repo):</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>{
</span></span><span style=display:flex><span>  description <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Customized Helix build with debug features&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  inputs <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    helix<span style=color:#f92672>.</span>url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;github:helix-editor/helix&#34;</span>;
</span></span><span style=display:flex><span>    nixpkgs<span style=color:#f92672>.</span>url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;github:nixos/nixpkgs/nixos-unstable&#34;</span>;
</span></span><span style=display:flex><span>    rust-overlay <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>      url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;github:oxalica/rust-overlay&#34;</span>;
</span></span><span style=display:flex><span>      inputs<span style=color:#f92672>.</span>nixpkgs<span style=color:#f92672>.</span>follows <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;nixpkgs&#34;</span>;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>  outputs <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    self<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>    helix<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>    nixpkgs<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>    rust-overlay<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>  }: <span style=color:#66d9ef>let</span>
</span></span><span style=display:flex><span>    system <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;x86_64-linux&#34;</span>;
</span></span><span style=display:flex><span>    pkgs <span style=color:#f92672>=</span> <span style=color:#f92672>import</span> nixpkgs {
</span></span><span style=display:flex><span>      system <span style=color:#f92672>=</span> system;
</span></span><span style=display:flex><span>      overlays <span style=color:#f92672>=</span> [rust-overlay<span style=color:#f92672>.</span>overlay<span style=color:#f92672>.</span>overlays<span style=color:#f92672>.</span>default];
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>in</span> {
</span></span><span style=display:flex><span>    packages<span style=color:#f92672>.</span><span style=color:#e6db74>${</span>system<span style=color:#e6db74>}</span><span style=color:#f92672>.</span>default <span style=color:#f92672>=</span> helix<span style=color:#f92672>.</span>packages<span style=color:#f92672>.</span><span style=color:#e6db74>${</span>system<span style=color:#e6db74>}</span><span style=color:#f92672>.</span>helix<span style=color:#f92672>.</span>overrideAttrs (old: {
</span></span><span style=display:flex><span>      buildType <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;debug&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e># Add additional cargo features</span>
</span></span><span style=display:flex><span>      cargoBuildFlags <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        (old<span style=color:#f92672>.</span>cargoBuildFlags or [])
</span></span><span style=display:flex><span>        <span style=color:#f92672>++</span> [
</span></span><span style=display:flex><span>          <span style=color:#e6db74>&#34;--features&#34;</span>
</span></span><span style=display:flex><span>          <span style=color:#e6db74>&#34;tokio-console&#34;</span>
</span></span><span style=display:flex><span>        ];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e># Inject custom RUSTFLAGS</span>
</span></span><span style=display:flex><span>      RUSTFLAGS <span style=color:#f92672>=</span> (old<span style=color:#f92672>.</span>RUSTFLAGS or <span style=color:#e6db74>&#34;&#34;</span>) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; -C debuginfo=2 -C opt-level=1&#34;</span>;
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Check it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>nix flake check
</span></span><span style=display:flex><span>warning: creating lock file <span style=color:#e6db74>&#39;&#34;/home/jr/world/flake.lock&#34;&#39;</span>:
</span></span><span style=display:flex><span>• Added input <span style=color:#e6db74>&#39;helix&#39;</span>:
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;github:helix-editor/helix/8961ae1dc66633ea6c9f761896cb0d885ae078ed?narHash=sha256-f14perPUk%2BH15GyGRbg0Akqhn3rxFnc6Ez5onqpzu6A%3D&#39;</span> <span style=color:#f92672>(</span>2025-05-29<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>• Added input <span style=color:#e6db74>&#39;helix/nixpkgs&#39;</span>:
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;github:nixos/nixpkgs/5135c59491985879812717f4c9fea69604e7f26f?narHash=sha256-Vr3Qi346M%2B8CjedtbyUevIGDZW8LcA1fTG0ugPY/Hic%3D&#39;</span> <span style=color:#f92672>(</span>2025-02-26<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>• Added input <span style=color:#e6db74>&#39;helix/rust-overlay&#39;</span>:
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;github:oxalica/rust-overlay/d342e8b5fd88421ff982f383c853f0fc78a847ab?narHash=sha256-3SdPQrZoa4odlScFDUHd4CUPQ/R1gtH4Mq9u8CBiK8M%3D&#39;</span> <span style=color:#f92672>(</span>2025-02-27<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>• Added input <span style=color:#e6db74>&#39;helix/rust-overlay/nixpkgs&#39;</span>:
</span></span><span style=display:flex><span>    follows <span style=color:#e6db74>&#39;helix/nixpkgs&#39;</span>
</span></span><span style=display:flex><span>• Added input <span style=color:#e6db74>&#39;nixpkgs&#39;</span>:
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;github:nixos/nixpkgs/96ec055edbe5ee227f28cdbc3f1ddf1df5965102?narHash=sha256-7doLyJBzCllvqX4gszYtmZUToxKvMUrg45EUWaUYmBg%3D&#39;</span> <span style=color:#f92672>(</span>2025-05-28<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>• Added input <span style=color:#e6db74>&#39;rust-overlay&#39;</span>:
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;github:oxalica/rust-overlay/405ef13a5b80a0a4d4fc87c83554423d80e5f929?narHash=sha256-k0nhPtkVDQkVJckRw6fGIeeDBktJf1BH0i8T48o7zkk%3D&#39;</span> <span style=color:#f92672>(</span>2025-05-30<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>• Added input <span style=color:#e6db74>&#39;rust-overlay/nixpkgs&#39;</span>:
</span></span><span style=display:flex><span>    follows <span style=color:#e6db74>&#39;nixpkgs&#39;</span>
</span></span></code></pre></div><ul><li>The <code>nix flake check</code> command will generate a <code>flake.lock</code> file if one doesn&rsquo;t
exist, and the warnings you see indicate that new inputs are being added and
locked to specific versions for reproducibility. This is expected behavior for
a new or modified flake.</li></ul><p>Inspect the outputs:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>nix flake show
</span></span><span style=display:flex><span>path:/home/jr/world?lastModified<span style=color:#f92672>=</span>1748612128&amp;narHash<span style=color:#f92672>=</span>sha256-WEYtptarRrrm0Jb/0PJ/b5VPqLkCk5iEenjbKYU4Xm8%3D
</span></span><span style=display:flex><span>└───packages
</span></span><span style=display:flex><span>    └───x86_64-linux
</span></span><span style=display:flex><span>        └───default: package <span style=color:#e6db74>&#39;helix-term&#39;</span>
</span></span></code></pre></div><ul><li><p>The <code>└───packages</code> line indicates that our flake exposes a top-level
<code>packages</code> attribute.</p></li><li><p><code>└───x86_64-linux</code>: System architecture specificity</p></li><li><p><code>└───default: package 'helix-term'</code> Signifies that within the <code>x86_64-linux</code>
packages, there&rsquo;s a package named <code>default</code>. This is a special name that
allows you to omit the package name when using commands like <code>nix build</code>.</p></li><li><p><code>package 'helix-term'</code> This is the most direct confirmation of our &ldquo;hack&rdquo;. It
tells us that our <code>default</code> package is <code>helix-term</code>. This confirms that our
<code>overrideAttrs</code> in the <code>packages.${system}.default</code> section successfully
targeted and modified the Helix editor package, which is internally named
<code>helix-term</code> by the Helix flake.</p></li></ul><p><strong>What This Does</strong>:</p><ul><li><p><code>overrideAttrs</code> lets you change <em>only</em> parts of the derivation without
rewriting everything.</p></li><li><p><code>buildType = "debug"</code> enables debug builds.</p></li><li><p><code>cargoBuildFlags</code> adds extra features passed to Cargo, e.g.,
<code>--features tokio-console</code></p></li><li><p><code>RUSTFLAGS</code> gives you even more control over compiler behavior, optimization
levels, etc.</p></li></ul><p><strong>Run It</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>nix run
</span></span></code></pre></div><p>Or drop into the dev shell:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>nix develop
</span></span></code></pre></div><ul><li>(assuming you also wire in a <code>devShells</code> output)</li></ul><p><strong>Adding the <code>devShells</code> output</strong>:</p><p>Since we already have the helix flake as an input to our own <code>flake.nix</code> we can
now forward or extend Helix&rsquo;s <code>devShells</code> like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>  outputs <span style=color:#f92672>=</span> { self<span style=color:#f92672>,</span> nixpkgs<span style=color:#f92672>,</span> helix<span style=color:#f92672>,</span> rust-overlay<span style=color:#f92672>,</span> <span style=color:#f92672>...</span> }: {
</span></span><span style=display:flex><span>    devShells <span style=color:#f92672>=</span> helix<span style=color:#f92672>.</span>devShells;
</span></span><span style=display:flex><span>  };
</span></span></code></pre></div><p>Or if you want to pick a specific system:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>  outputs <span style=color:#f92672>=</span> { self<span style=color:#f92672>,</span> nixpkgs<span style=color:#f92672>,</span> helix<span style=color:#f92672>,</span> rust-overlay <span style=color:#f92672>...</span> }:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span>
</span></span><span style=display:flex><span>      system <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;x86_64-linux&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>in</span> {
</span></span><span style=display:flex><span>      devShells<span style=color:#f92672>.</span><span style=color:#e6db74>${</span>system<span style=color:#e6db74>}</span> <span style=color:#f92672>=</span> helix<span style=color:#f92672>.</span>devShells<span style=color:#f92672>.</span><span style=color:#e6db74>${</span>system<span style=color:#e6db74>}</span>;
</span></span><span style=display:flex><span>    };
</span></span></code></pre></div><p><strong>Optional: Combine with your own</strong> <code>devShell</code></p><p>You can also extend or merge it with your own shell like so:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>  outputs <span style=color:#f92672>=</span> { self<span style=color:#f92672>,</span> nixpkgs<span style=color:#f92672>,</span> helix<span style=color:#f92672>,</span> rust-overlay<span style=color:#f92672>,</span> <span style=color:#f92672>...</span> }:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span>
</span></span><span style=display:flex><span>      system <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;x86_64-linux&#34;</span>;
</span></span><span style=display:flex><span>      pkgs <span style=color:#f92672>=</span> <span style=color:#f92672>import</span> nixpkgs { <span style=color:#66d9ef>inherit</span> system; };
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>in</span> {
</span></span><span style=display:flex><span>      devShells<span style=color:#f92672>.</span><span style=color:#e6db74>${</span>system<span style=color:#e6db74>}</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>        default <span style=color:#f92672>=</span> pkgs<span style=color:#f92672>.</span>mkShell {
</span></span><span style=display:flex><span>          name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;my-shell&#34;</span>;
</span></span><span style=display:flex><span>          inputsFrom <span style=color:#f92672>=</span> [ helix<span style=color:#f92672>.</span>devShells<span style=color:#f92672>.</span><span style=color:#e6db74>${</span>system<span style=color:#e6db74>}</span><span style=color:#f92672>.</span>default ];
</span></span><span style=display:flex><span>          buildInputs <span style=color:#f92672>=</span> [ pkgs<span style=color:#f92672>.</span>git ];
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>      };
</span></span><span style=display:flex><span>    };
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://tsawyer87.github.io/>NixOS Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>