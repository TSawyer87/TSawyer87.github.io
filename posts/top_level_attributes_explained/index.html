<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Top_level_attributes_explained | NixOS Blog</title><meta name=keywords content><meta name=description content="Understanding Top-Level Attributes in NixOS Modules
This explanation is based on insights from Infinisil, a prominent figure in the
Nix community, to help clarify the concept of top-level attributes within NixOS
modules.
The Core of a NixOS System: system.build.toplevel
In a NixOS system, everything is built from a single &ldquo;system derivation.&rdquo; The
command nix-build '<nixpkgs/nixos>' -A system initiates this build process.
The -A system part tells Nix to focus on the system attribute defined in the
'<nixpkgs/nixos>' file (which is essentially ./default.nix within the
Nixpkgs repository)."><meta name=author content="T Sawyer"><link rel=canonical href=https://tsawyer87.github.io/posts/top_level_attributes_explained/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://tsawyer87.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://tsawyer87.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://tsawyer87.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://tsawyer87.github.io/apple-touch-icon.png><link rel=mask-icon href=https://tsawyer87.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://tsawyer87.github.io/posts/top_level_attributes_explained/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://tsawyer87.github.io/posts/top_level_attributes_explained/"><meta property="og:site_name" content="NixOS Blog"><meta property="og:title" content="Top_level_attributes_explained"><meta property="og:description" content="Understanding Top-Level Attributes in NixOS Modules This explanation is based on insights from Infinisil, a prominent figure in the Nix community, to help clarify the concept of top-level attributes within NixOS modules.
The Core of a NixOS System: system.build.toplevel In a NixOS system, everything is built from a single “system derivation.” The command nix-build '<nixpkgs/nixos>' -A system initiates this build process.
The -A system part tells Nix to focus on the system attribute defined in the '<nixpkgs/nixos>' file (which is essentially ./default.nix within the Nixpkgs repository)."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-14T19:20:34-04:00"><meta property="article:modified_time" content="2025-05-14T19:20:34-04:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Top_level_attributes_explained"><meta name=twitter:description content="Understanding Top-Level Attributes in NixOS Modules
This explanation is based on insights from Infinisil, a prominent figure in the
Nix community, to help clarify the concept of top-level attributes within NixOS
modules.
The Core of a NixOS System: system.build.toplevel
In a NixOS system, everything is built from a single &ldquo;system derivation.&rdquo; The
command nix-build '<nixpkgs/nixos>' -A system initiates this build process.
The -A system part tells Nix to focus on the system attribute defined in the
'<nixpkgs/nixos>' file (which is essentially ./default.nix within the
Nixpkgs repository)."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tsawyer87.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Top_level_attributes_explained","item":"https://tsawyer87.github.io/posts/top_level_attributes_explained/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Top_level_attributes_explained","name":"Top_level_attributes_explained","description":"Understanding Top-Level Attributes in NixOS Modules This explanation is based on insights from Infinisil, a prominent figure in the Nix community, to help clarify the concept of top-level attributes within NixOS modules.\nThe Core of a NixOS System: system.build.toplevel In a NixOS system, everything is built from a single \u0026ldquo;system derivation.\u0026rdquo; The command nix-build '\u0026lt;nixpkgs/nixos\u0026gt;' -A system initiates this build process.\nThe -A system part tells Nix to focus on the system attribute defined in the '\u0026lt;nixpkgs/nixos\u0026gt;' file (which is essentially ./default.nix within the Nixpkgs repository).\n","keywords":[],"articleBody":"Understanding Top-Level Attributes in NixOS Modules This explanation is based on insights from Infinisil, a prominent figure in the Nix community, to help clarify the concept of top-level attributes within NixOS modules.\nThe Core of a NixOS System: system.build.toplevel In a NixOS system, everything is built from a single “system derivation.” The command nix-build '' -A system initiates this build process.\nThe -A system part tells Nix to focus on the system attribute defined in the '' file (which is essentially ./default.nix within the Nixpkgs repository).\nThis system attribute is specifically the NixOS option system.build.toplevel . Think of system.build.toplevel as the very top of the configuration hierarchy for your entire NixOS system. Almost every setting you configure eventually influences this top-level derivation, often through a series of intermediate steps.\nKey Takeaway: system.build.toplevel is the ultimate output that defines your entire NixOS system.\nHow Options Relate: A Chain of Influence Options in NixOS are not isolated; they often build upon each other. Here’s an example of how a high-level option can lead down to a low-level system configuration:\nYou enable Nginx with services.nginx.enable = true;. This setting influences the lower-level option systemd.services.nginx. Which, in turn, affects the even lower-level option systemd.units.\"nginx.service\". Ultimately, this leads to the creation of a systemd unit file within environment.etc.\"systemd/system\". Finally, this unit file ends up as result/etc/systemd/system/nginx.service within the final system.build.toplevel derivation. Key Takeaway: Higher-level, user-friendly options are translated into lower-level system configurations that are part of the final system build.\nThe NixOS Module System: Evaluating Options So, how do these options get processed and turned into the final system configuration? That’s the job of the NixOS module system, located in the ./lib directory of Nixpkgs (specifically in modules.nix, options.nix, and types.nix).\nInterestingly, the module system isn’t exclusive to NixOS; you can use it to manage option sets in your own Nix projects.\nHere’s a simplified example of using the module system outside of NixOS:\nlet systemModule = { lib, config, ... }: { options.toplevel = lib.mkOption { type = lib.types.str; }; options.enableFoo = lib.mkOption { type = lib.types.bool; default = false; }; config.toplevel = '' Is foo enabled? ${lib.boolToString config.enableFoo} ''; }; userModule = { enableFoo = true; }; in (import ).evalModules { modules = [ systemModule userModule ]; } You can evaluate the config.toplevel option from this example using:\nnix-instantiate --eval file.nix -A config.toplevel Key Takeaway: The NixOS module system is responsible for evaluating and merging option configurations from different modules.\nHow the Module System Works: A Simplified Overview The module system processes a set of “modules” through these general steps:\nImporting Modules: It recursively finds and includes all modules specified in imports = [ ... ]; statements.\nDeclaring Options: It collects all option declarations defined using options = { ... }; from all the modules and merges them. If the same option is declared in multiple modules, the module system handles this (details omitted for simplicity).\nDefining Option Values: For each declared option, it gathers all the value assignments (defined using config = { ... }; or directly at the top level if no options or config are present) from all modules and merges them according to the option’s defined type.\nImportant Note: Option evaluation is lazy, meaning an option’s value is only computed when it’s actually needed. It can also depend on the values of other options.\nKey Takeaway: The module system imports, declares, and then evaluates option values from various modules to build the final configuration.\nTop-Level Attributes in a Module: imports, options, and config\nWithin a NixOS module (the files that define parts of your system configuration) , the attributes defined directly at the top level of the module’s function have specific meanings:\nimports: This attribute is a list of other module files to include. Their options and configurations will also be part of the evaluation.\noptions: This attribute is where you declare new configuration options. You define their type, default value, description, etc., using functions like lib.mkOption or lib.mkEnableOption.\nconfig: This attribute is where you assign values to the options that have been declared (either in the current module or in imported modules).\nKey Takeaway: The top-level attributes imports, options, and config are the primary ways to structure a NixOS module.\nThe Rule: Move Non-Option Attributes Under config\nIf you define either an options or a config attribute at the top level of your module, any other attributes that are not option declarations must be moved inside the config attribute.\nLet’s look at an example of what not to do:\n{ pkgs, lib, config, ... }: { imports = []; # Defining an option at the top level options.mine.desktop.enable = lib.mkEnableOption \"desktop settings\"; # This will cause an error because 'environment' and 'appstream' # are not 'options' and 'config' is also present at the top level. environment.systemPackages = lib.mkIf config.appstream.enable [ pkgs.git ]; appstream.enable = true; } This will result in the error: error: Module has an unsupported attribute 'appstream' This is caused by introducing a top-level 'config' or 'options' attribute. Add configuration attributes immediately on the top level instead, or move all of them into the explicit 'config' attribute.\nKey Takeaway: When you have options or config at the top level, all value assignments need to go inside the config block.\nThe Correct Way): Using the config Attribute\nTo fix the previous example, you need to move the value assignments for environment.systemPackages and appstream.enable inside the config attribute:\n{ pkgs, lib, config, ... }: { imports = []; # Defining an option at the top level options.mine.desktop.enable = lib.mkEnableOption \"desktop settings\"; config = { environment.systemPackages = lib.mkIf config.appstream.enable [ pkgs.git ]; appstream.enable = true; }; } Now, Nix knows that you are declaring an option (options.mine.desktop.enable) and then setting values for other options (environment.systemPackages, appstream.enable) within the config block.\nKey Takeaway: The config attribute is used to define the values of options.\nImplicit config: When options is Absent\nIf your module does not define either options or config at the top level, then any attributes you define directly at the top level are implicitly treated as being part of the config.\nFor example, this is valid:\n{ pkgs, lib, config, ... }: { environment.systemPackages = lib.mkIf config.appstream.enable [ pkgs.git ]; appstream.enable = true; } Nix will implicitly understand that environment.systemPackages and appstream.enable are configuration settings.\nKey Takeaway: If no explicit options or config are present, top-level attributes are automatically considered part of the configuration.\nRemoving an Option: What Happens to config\nEven if you remove the options declaration from a module that has a config section, the config = { environment.systemPackages = ... }; part will still function correctly, assuming the option it’s referencing (appstream.enable in this case) is defined elsewhere (e.g., in an imported module).\nKey Takeaway: The config section defines values for options, regardless of whether those options are declared in the same module.\n","wordCount":"1138","inLanguage":"en","datePublished":"2025-05-14T19:20:34-04:00","dateModified":"2025-05-14T19:20:34-04:00","author":{"@type":"Person","name":"T Sawyer"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://tsawyer87.github.io/posts/top_level_attributes_explained/"},"publisher":{"@type":"Organization","name":"NixOS Blog","logo":{"@type":"ImageObject","url":"https://tsawyer87.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tsawyer87.github.io/ accesskey=h title="NixOS Blog (Alt + H)">NixOS Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
<a href=/index.xml title="RSS Feed"><img src=/images/rss.png alt="RSS Feed" style=width:24px;height:24px></a></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Top_level_attributes_explained</h1><div class=post-meta><span title='2025-05-14 19:20:34 -0400 EDT'>May 14, 2025</span>&nbsp;·&nbsp;T Sawyer</div></header><div class=post-content><h1 id=understanding-top-level-attributes-in-nixos-modules>Understanding Top-Level Attributes in NixOS Modules<a hidden class=anchor aria-hidden=true href=#understanding-top-level-attributes-in-nixos-modules>#</a></h1><p>This explanation is based on insights from Infinisil, a prominent figure in the
Nix community, to help clarify the concept of top-level attributes within NixOS
modules.</p><h2 id=the-core-of-a-nixos-system-systembuildtoplevel>The Core of a NixOS System: <code>system.build.toplevel</code><a hidden class=anchor aria-hidden=true href=#the-core-of-a-nixos-system-systembuildtoplevel>#</a></h2><p>In a NixOS system, everything is built from a single &ldquo;system derivation.&rdquo; The
command <code>nix-build '&lt;nixpkgs/nixos>' -A system</code> initiates this build process.</p><p>The <code>-A system</code> part tells Nix to focus on the <code>system</code> attribute defined in the
<code>'&lt;nixpkgs/nixos>'</code> file (which is essentially <code>./default.nix</code> within the
Nixpkgs repository).</p><p>This <code>system</code> attribute is specifically the NixOS option <code>system.build.toplevel</code>
. Think of <code>system.build.toplevel</code> as the <strong>very top of the configuration
hierarchy</strong> for your entire NixOS system. Almost every setting you configure
eventually influences this top-level derivation, often through a series of
intermediate steps.</p><p><strong>Key Takeaway:</strong> <code>system.build.toplevel</code> is the ultimate output that defines
your entire NixOS system.</p><h2 id=how-options-relate-a-chain-of-influence>How Options Relate: A Chain of Influence<a hidden class=anchor aria-hidden=true href=#how-options-relate-a-chain-of-influence>#</a></h2><p>Options in NixOS are not isolated; they often build upon each other. Here&rsquo;s an
example of how a high-level option can lead down to a low-level system
configuration:</p><ul><li>You enable Nginx with <code>services.nginx.enable = true;</code>.</li><li>This setting influences the lower-level option <code>systemd.services.nginx</code>.</li><li>Which, in turn, affects the even lower-level option
<code>systemd.units."nginx.service"</code>.</li><li>Ultimately, this leads to the creation of a systemd unit file within
<code>environment.etc."systemd/system"</code>.</li><li>Finally, this unit file ends up as <code>result/etc/systemd/system/nginx.service</code>
within the final <code>system.build.toplevel</code> derivation.</li></ul><p><strong>Key Takeaway:</strong> Higher-level, user-friendly options are translated into
lower-level system configurations that are part of the final system build.</p><h2 id=the-nixos-module-system-evaluating-options>The NixOS Module System: Evaluating Options<a hidden class=anchor aria-hidden=true href=#the-nixos-module-system-evaluating-options>#</a></h2><p>So, how do these options get processed and turned into the final system
configuration? That&rsquo;s the job of the <strong>NixOS module system</strong>, located in the
<code>./lib</code> directory of Nixpkgs (specifically in <code>modules.nix</code>, <code>options.nix</code>, and
<code>types.nix</code>).</p><p>Interestingly, the module system isn&rsquo;t exclusive to NixOS; you can use it to
manage option sets in your own Nix projects.</p><p>Here&rsquo;s a simplified example of using the module system outside of NixOS:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span><span style=color:#66d9ef>let</span>
</span></span><span style=display:flex><span>  systemModule <span style=color:#f92672>=</span> { lib<span style=color:#f92672>,</span> config<span style=color:#f92672>,</span> <span style=color:#f92672>...</span> }: {
</span></span><span style=display:flex><span>    options<span style=color:#f92672>.</span>toplevel <span style=color:#f92672>=</span> lib<span style=color:#f92672>.</span>mkOption {
</span></span><span style=display:flex><span>      type <span style=color:#f92672>=</span> lib<span style=color:#f92672>.</span>types<span style=color:#f92672>.</span>str;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    options<span style=color:#f92672>.</span>enableFoo <span style=color:#f92672>=</span> lib<span style=color:#f92672>.</span>mkOption {
</span></span><span style=display:flex><span>      type <span style=color:#f92672>=</span> lib<span style=color:#f92672>.</span>types<span style=color:#f92672>.</span>bool;
</span></span><span style=display:flex><span>      default <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    config<span style=color:#f92672>.</span>toplevel <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      Is foo enabled? </span><span style=color:#e6db74>${</span>lib<span style=color:#f92672>.</span>boolToString config<span style=color:#f92672>.</span>enableFoo<span style=color:#e6db74>}</span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#39;&#39;</span>;
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  userModule <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    enableFoo <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>in</span> (<span style=color:#f92672>import</span> <span style=color:#e6db74>&lt;nixpkgs/lib&gt;</span>)<span style=color:#f92672>.</span>evalModules {
</span></span><span style=display:flex><span>  modules <span style=color:#f92672>=</span> [ systemModule userModule ];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>You can evaluate the <code>config.toplevel</code> option from this example using:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>nix-instantiate --eval file.nix -A config.toplevel
</span></span></code></pre></div><p><strong>Key Takeaway</strong>: The NixOS module system is responsible for evaluating and
merging option configurations from different modules.</p><h2 id=how-the-module-system-works-a-simplified-overview>How the Module System Works: A Simplified Overview<a hidden class=anchor aria-hidden=true href=#how-the-module-system-works-a-simplified-overview>#</a></h2><p>The module system processes a set of &ldquo;modules&rdquo; through these general steps:</p><ol><li><p><strong>Importing Modules</strong>: It recursively finds and includes all modules
specified in <code>imports = [ ... ];</code> statements.</p></li><li><p><strong>Declaring Options</strong>: It collects all option declarations defined using
<code>options = { ... };</code> from all the modules and merges them. If the same option
is declared in multiple modules, the module system handles this (details
omitted for simplicity).</p></li><li><p><strong>Defining Option Values</strong>: For each declared option, it gathers all the
value assignments (defined using <code>config = { ... };</code> or directly at the top
level if no <code>options</code> or <code>config</code> are present) from all modules and merges
them according to the option&rsquo;s defined type.</p></li></ol><blockquote><p><strong>Important Note</strong>: Option evaluation is lazy, meaning an option&rsquo;s value is
only computed when it&rsquo;s actually needed. It can also depend on the values of
other options.</p></blockquote><p><strong>Key Takeaway</strong>: The module system imports, declares, and then evaluates option
values from various modules to build the final configuration.</p><p><strong>Top-Level Attributes in a Module: <code>imports</code>, <code>options</code>, and <code>config</code></strong></p><p>Within a NixOS module (the files that define parts of your system configuration)
, the attributes defined directly at the top level of the module&rsquo;s function have
specific meanings:</p><ul><li><p><code>imports</code>: This attribute is a list of other module files to include. Their
options and configurations will also be part of the evaluation.</p></li><li><p><code>options</code>: This attribute is where you declare new configuration options. You
define their type, default value, description, etc., using functions like
<code>lib.mkOption</code> or <code>lib.mkEnableOption</code>.</p></li><li><p><code>config</code>: This attribute is where you assign values to the options that have
been declared (either in the current module or in imported modules).</p></li></ul><p><strong>Key Takeaway</strong>: The top-level attributes <code>imports</code>, <code>options</code>, and <code>config</code>
are the primary ways to structure a NixOS module.</p><p><strong>The Rule: Move Non-Option Attributes Under <code>config</code></strong></p><p>If you define either an <code>options</code> or a <code>config</code> attribute at the top level of
your module, any other attributes that are not option declarations must be moved
inside the config attribute.</p><p>Let&rsquo;s look at an example of what not to do:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>{ pkgs<span style=color:#f92672>,</span> lib<span style=color:#f92672>,</span> config<span style=color:#f92672>,</span> <span style=color:#f92672>...</span> }:
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>imports <span style=color:#f92672>=</span> [];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Defining an option at the top level</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>options<span style=color:#f92672>.</span>mine<span style=color:#f92672>.</span>desktop<span style=color:#f92672>.</span>enable <span style=color:#f92672>=</span> lib<span style=color:#f92672>.</span>mkEnableOption <span style=color:#e6db74>&#34;desktop settings&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># This will cause an error because &#39;environment&#39; and &#39;appstream&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># are not &#39;options&#39; and &#39;config&#39; is also present at the top level.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>environment<span style=color:#f92672>.</span>systemPackages <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>lib<span style=color:#f92672>.</span>mkIf config<span style=color:#f92672>.</span>appstream<span style=color:#f92672>.</span>enable [ pkgs<span style=color:#f92672>.</span>git ];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>appstream<span style=color:#f92672>.</span>enable <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This will result in the error:
<code>error: Module has an unsupported attribute 'appstream' This is caused by introducing a top-level 'config' or 'options' attribute. Add configuration attributes immediately on the top level instead, or move all of them into the explicit 'config' attribute</code>.</p><p><strong>Key Takeaway</strong>: When you have <code>options</code> or <code>config</code> at the top level, all
value assignments need to go inside the config block.</p><p><strong>The Correct Way</strong>): Using the <code>config</code> Attribute</p><p>To fix the previous example, you need to move the value assignments for
<code>environment.systemPackages</code> and <code>appstream.enable</code> inside the config attribute:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>{ pkgs<span style=color:#f92672>,</span> lib<span style=color:#f92672>,</span> config<span style=color:#f92672>,</span> <span style=color:#f92672>...</span> }:
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>imports <span style=color:#f92672>=</span> [];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Defining an option at the top level</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>options<span style=color:#f92672>.</span>mine<span style=color:#f92672>.</span>desktop<span style=color:#f92672>.</span>enable <span style=color:#f92672>=</span> lib<span style=color:#f92672>.</span>mkEnableOption <span style=color:#e6db74>&#34;desktop settings&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>config <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>environment<span style=color:#f92672>.</span>systemPackages <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>lib<span style=color:#f92672>.</span>mkIf config<span style=color:#f92672>.</span>appstream<span style=color:#f92672>.</span>enable [ pkgs<span style=color:#f92672>.</span>git ];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    appstream<span style=color:#f92672>.</span>enable <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now, Nix knows that you are declaring an option (<code>options.mine.desktop.enable</code>)
and then setting values for other options (<code>environment.systemPackages</code>,
<code>appstream.enable</code>) within the <code>config</code> block.</p><p><strong>Key Takeaway</strong>: The <code>config</code> attribute is used to define the values of
options.</p><p><strong>Implicit <code>config</code>: When <code>options</code> is Absent</strong></p><p>If your module does not define either <code>options</code> or <code>config</code> at the top level,
then any attributes you define directly at the top level are implicitly treated
as being part of the config.</p><p>For example, this is valid:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>{ pkgs<span style=color:#f92672>,</span> lib<span style=color:#f92672>,</span> config<span style=color:#f92672>,</span> <span style=color:#f92672>...</span> }:
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>environment<span style=color:#f92672>.</span>systemPackages <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>lib<span style=color:#f92672>.</span>mkIf config<span style=color:#f92672>.</span>appstream<span style=color:#f92672>.</span>enable [ pkgs<span style=color:#f92672>.</span>git ];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>appstream<span style=color:#f92672>.</span>enable <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Nix will implicitly understand that <code>environment.systemPackages</code> and
<code>appstream.enable</code> are configuration settings.</p><p><strong>Key Takeaway</strong>: If no explicit options or config are present, top-level
attributes are automatically considered part of the configuration.</p><p><strong>Removing an Option: What Happens to <code>config</code></strong></p><p>Even if you remove the <code>options</code> declaration from a module that has a <code>config</code>
section, the <code>config = { environment.systemPackages = ... };</code> part will still
function correctly, assuming the option it&rsquo;s referencing (<code>appstream.enable</code> in
this case) is defined elsewhere (e.g., in an imported module).</p><p><strong>Key Takeaway</strong>: The <code>config</code> section defines values for options, regardless of
whether those options are declared in the same module.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://tsawyer87.github.io/>NixOS Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>