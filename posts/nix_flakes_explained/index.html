<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Nix_flakes_explained | NixOS Blog</title><meta name=keywords content><meta name=description content="Nix Flakes Explained
This explanation highlights common areas of confusion for those new to Nix
Flakes, aiming to clarify concepts rather than serve as a comprehensive guide.
What is a Nix Flake?


At its core, a flake is a source tree (like a Git repository) that contains a
flake.nix file. This file provides a standardized way to access Nix
artifacts such as packages and modules.


Think of flake.nix as the central entry point of a flake. It not only
defines what the flake produces but also declares its dependencies."><meta name=author content="T Sawyer"><link rel=canonical href=https://tsawyer87.github.io/posts/nix_flakes_explained/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://tsawyer87.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://tsawyer87.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://tsawyer87.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://tsawyer87.github.io/apple-touch-icon.png><link rel=mask-icon href=https://tsawyer87.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://tsawyer87.github.io/posts/nix_flakes_explained/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://tsawyer87.github.io/posts/nix_flakes_explained/"><meta property="og:site_name" content="NixOS Blog"><meta property="og:title" content="Nix_flakes_explained"><meta property="og:description" content="Nix Flakes Explained This explanation highlights common areas of confusion for those new to Nix Flakes, aiming to clarify concepts rather than serve as a comprehensive guide.
What is a Nix Flake? At its core, a flake is a source tree (like a Git repository) that contains a flake.nix file. This file provides a standardized way to access Nix artifacts such as packages and modules.
Think of flake.nix as the central entry point of a flake. It not only defines what the flake produces but also declares its dependencies."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-14T19:19:51-04:00"><meta property="article:modified_time" content="2025-05-14T19:19:51-04:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Nix_flakes_explained"><meta name=twitter:description content="Nix Flakes Explained
This explanation highlights common areas of confusion for those new to Nix
Flakes, aiming to clarify concepts rather than serve as a comprehensive guide.
What is a Nix Flake?


At its core, a flake is a source tree (like a Git repository) that contains a
flake.nix file. This file provides a standardized way to access Nix
artifacts such as packages and modules.


Think of flake.nix as the central entry point of a flake. It not only
defines what the flake produces but also declares its dependencies."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tsawyer87.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Nix_flakes_explained","item":"https://tsawyer87.github.io/posts/nix_flakes_explained/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Nix_flakes_explained","name":"Nix_flakes_explained","description":"Nix Flakes Explained This explanation highlights common areas of confusion for those new to Nix Flakes, aiming to clarify concepts rather than serve as a comprehensive guide.\nWhat is a Nix Flake? At its core, a flake is a source tree (like a Git repository) that contains a flake.nix file. This file provides a standardized way to access Nix artifacts such as packages and modules.\nThink of flake.nix as the central entry point of a flake. It not only defines what the flake produces but also declares its dependencies.\n","keywords":[],"articleBody":"Nix Flakes Explained This explanation highlights common areas of confusion for those new to Nix Flakes, aiming to clarify concepts rather than serve as a comprehensive guide.\nWhat is a Nix Flake? At its core, a flake is a source tree (like a Git repository) that contains a flake.nix file. This file provides a standardized way to access Nix artifacts such as packages and modules.\nThink of flake.nix as the central entry point of a flake. It not only defines what the flake produces but also declares its dependencies.\nKey Concepts ** flake.nix: The Heart of a Flake**\nThe flake.nix file is mandatory for any flake. It must contain an attribute set with at least one required attribute: outputs. It can also optionally include description and inputs. Basic Structure: { description = \"Package description\"; inputs = { /* Dependencies go here */ }; outputs = { /* What the flake produces */ }; nixConfig = { /* Advanced configuration options */ }; } Attribute Sets: The Building Blocks Attribute sets are fundamental in Nix. They are simply collections of name-value pairs wrapped in curly braces {}.\nExample: let my_attrset = { foo = \"bar\"; }; in my_attrset.foo Output: \"bar\" Top-Level Attributes of a Flake:\nFlakes have specific top-level attributes that can be accessed directly (without dot notation). The most common ones are inputs, outputs, and nixConfig. Anatomy of flake.nix inputs: Declaring Dependencies\nThe inputs attribute set specifies the other flakes that your current flake depends on.\nEach key in the inputs set is a name you choose for the dependency, and the value is a reference to that flake (usually a URL or a Git Repo).\nTo access something from a dependency, you generally go through the inputs attribute (e.g., inputs.helix.packages).\nExample: This declares dependencies on the nixpkgs and import-cargo flakes: inputs = { import-cargo.url = \"github:edolstra/import-cargo\"; nixpkgs.url = \"nixpkgs\"; }; When Nix evaluates your flake, it fetches and evaluates each input. These evaluated inputs are then passed as an attribute set to the outputs function, with the keys matching the names you gave them in the inputs set.\nThe special input self is a reference to the outputs and the source tree of the current flake itself.\noutputs: Defining What Your Flake Provides\nThe outputs attribute defines what your flake makes available. This can include packages, NixOS modules, development environments (devShells) and other Nix derivations.\nFlakes can output arbitrary Nix values. However, certain outputs have specific meanings for Nix commands and must adhere to particular types (often derivations, as described in the output schema).\nYou can inspect the outputs of a flake using the command:\nnix flake show This command takes a flake URI and displays its outputs in a tree structure, showing the attribute paths and their corresponding types.\nUnderstanding the outputs Function\nBeginners often mistakenly think that self and nixpkgs within outputs = { self, nixpkgs, ... }: { ... } are the outputs themselves. Instead, they are the input arguments (often called output arguments) to the outputs function.\nThe outputs function in flake.nix always takes a single argument, which is an attribute set. The syntax { self, nixpkgs, ... } is Nix’s way of destructuring this single input attribute set to extract the values associated with the keys self and nixpkgs.\nReferencing the Current Flake (self)\nself provides a way to refer back to the current flake from within the outputs function. You can use it to access other top-level attributes like inputs (e.g., self.inputs).\nThe outputs function always receives an argument conventionally named self, which represents the entire flake, including all its top-level attributes. You’ll typically use self to reference things defined within your own flake (e.g., self.packages.my-package).\nVariadic Attributes (…) and @-patterns\nThe ... syntax in the input arguments of the outputs function indicates variadic attributes, meaning the input attribute set can contain more attributes than just those explicitly listed (like self and nixpkgs).\nExample:\nmul = { a, b, ... }: a \\* b; mul { a = 3; b = 4; c = 2; } # 'c' is an extra attribute However, you cannot directly access these extra attributes within the function body unless you use the @-pattern:\nmul = s@{ a, b, ... }: a _ b _ s.c; # 's' now refers to the entire input set mul { a = 3; b = 4; c = 2; } # Output: 24 When used in the outputs function argument list (e.g., outputs = { pkgs, ... } @ inputs), the @-pattern binds the entire input attribute set to a name (in this case, inputs) while also allowing you to destructure specific attributes like pkgs.\nWhat outputs = { pkgs, ... } @ inputs: { ... }; does:\nDestructuring: It tries to extract the value associated with the key pkgs from the input attribute set and binds it to the variable pkgs. The ... allows for other keys in the input attribute set to be ignored during this direct destructuring.\nBinding the Entire Set: It binds the entire input attribute set to the variable inputs.\nExample flake.nix: { inputs.nixpkgs.url = \"github:NixOS/nixpkgs/nixos-unstable\"; inputs.home-manager.url = \"github:nix-community/home-manager\"; outputs = { self, nixpkgs, ... } @ attrs: { # A `packages` output for the x86_64-linux platform packages.x86_64-linux.hello = nixpkgs.legacyPackages.x86_64-linux.hello; # A `nixosConfigurations` output (for a NixOS system named \"fnord\") nixosConfigurations.fnord = nixpkgs.lib.nixosSystem { system = \"x86_64-linux\"; specialArgs = attrs; modules = [ ./configuration.nix ]; }; }; } Platform Specificity in Outputs\nFlakes ensure that their outputs are consistent across different evaluation environments. Therefore, any package-related output must explicitly specify the target platform (a combination of architecture and OS, x86_64-linux). legacyPackages Explained\nlegacyPackages is a way for flakes to interact with the traditional, less structured package organization of nixpkgs. Instead of packages being directly at the top level (e.g., pkgs.hello), legacyPackages provides a platform-aware way to access them within the flake’s structured output format (e.g., nixpkgs.legacyPackages.x86_64-linux.hello). It acts as a bridge between the flake’s expected output structure and nixpkgs’s historical organization. The Sole Argument of outputs\nIt’s crucial to remember that the outputs function accepts only one argument, which is an attribute set. The { self, nixpkgs, ... } syntax is simply destructuring that single input attribute set. Outputs of the Flake (Return Value)\nThe outputs of the flake refer to the attribute set that is returned by the outputs function. This attribute set can contain various named outputs like packages, nixosConfigurations, devShells, etc. Imports: Including Other Nix Expressions\nThe import function in Nix is used to evaluate the Nix expression found at a specified path (usually a file or directory) and return its value.\nBasic Usage: import ./path/to/file.nix\nPassing Arguments During Import\nYou can also pass an attribute set as an argument to the Nix expression being imported: let myHelpers = import ./lib/my-helpers.nix { pkgs = nixpkgs; }; in # ... use myHelpers In this case, the Nix expression in ./lib/my-helpers.nix is likely a function that expects an argument (often named pkgs by convention): # ./lib/my-helpers.nix { pkgs }: let myPackage = pkgs.stdenv.mkDerivation { name = \"my-package\"; # ... }; in myPackage By passing { pkgs = nixpkgs; } during the import, you are providing the nixpkgs value from your current flake.nix scope to the pkgs parameter expected by the code in ./lib/my-helpers.nix. Importing Directories (default.nix)\nWhen you use import with a path that points to a directory, Nix automatically looks for a file named default.nix within that directory. If found, Nix evaluates the expressions within default.nix as if you had specified its path directly in the import statement. Further Resources practical-nix-flakes\ntweag nix-flakes\nNixOS-wiki Flakes\nnix.dev flakes\nflakes-arent-real\nwombats-book-of-nix\nzero-to-nix flakes\nnixos-and-flakes-book\nFlakeHub\n","wordCount":"1269","inLanguage":"en","datePublished":"2025-05-14T19:19:51-04:00","dateModified":"2025-05-14T19:19:51-04:00","author":{"@type":"Person","name":"T Sawyer"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://tsawyer87.github.io/posts/nix_flakes_explained/"},"publisher":{"@type":"Organization","name":"NixOS Blog","logo":{"@type":"ImageObject","url":"https://tsawyer87.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tsawyer87.github.io/ accesskey=h title="NixOS Blog (Alt + H)">NixOS Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
<a href=/index.xml title="RSS Feed"><img src=/images/rss.png alt="RSS Feed" style=width:24px;height:24px></a></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Nix_flakes_explained</h1><div class=post-meta><span title='2025-05-14 19:19:51 -0400 EDT'>May 14, 2025</span>&nbsp;·&nbsp;T Sawyer</div></header><div class=post-content><h1 id=nix-flakes-explained>Nix Flakes Explained<a hidden class=anchor aria-hidden=true href=#nix-flakes-explained>#</a></h1><p>This explanation highlights common areas of confusion for those new to Nix
Flakes, aiming to clarify concepts rather than serve as a comprehensive guide.</p><h2 id=what-is-a-nix-flake>What is a Nix Flake?<a hidden class=anchor aria-hidden=true href=#what-is-a-nix-flake>#</a></h2><ul><li><p>At its core, a flake is a source tree (like a Git repository) that contains a
<code>flake.nix</code> file. This file provides a standardized way to access Nix
artifacts such as packages and modules.</p></li><li><p>Think of <code>flake.nix</code> as the central entry point of a flake. It not only
defines what the flake produces but also declares its dependencies.</p></li></ul><h2 id=key-concepts>Key Concepts<a hidden class=anchor aria-hidden=true href=#key-concepts>#</a></h2><p>** <code>flake.nix</code>: The Heart of a Flake**</p><ul><li>The <code>flake.nix</code> file is mandatory for any flake. It must contain an attribute
set with at least one required attribute: <code>outputs</code>. It can also optionally
include <code>description</code> and <code>inputs</code>.</li><li><strong>Basic Structure:</strong></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>{
</span></span><span style=display:flex><span>  description <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Package description&#34;</span>;
</span></span><span style=display:flex><span>  inputs <span style=color:#f92672>=</span> { <span style=color:#75715e>/* Dependencies go here */</span> };
</span></span><span style=display:flex><span>  outputs <span style=color:#f92672>=</span> { <span style=color:#75715e>/* What the flake produces */</span> };
</span></span><span style=display:flex><span>  nixConfig <span style=color:#f92672>=</span> { <span style=color:#75715e>/* Advanced configuration options */</span> };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=attribute-sets-the-building-blocks>Attribute Sets: The Building Blocks<a hidden class=anchor aria-hidden=true href=#attribute-sets-the-building-blocks>#</a></h2><ul><li><p>Attribute sets are fundamental in Nix. They are simply collections of
name-value pairs wrapped in curly braces <code>{}</code>.</p><ul><li>Example:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span><span style=color:#66d9ef>let</span>
</span></span><span style=display:flex><span>  my_attrset <span style=color:#f92672>=</span> { foo <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;bar&#34;</span>; };
</span></span><span style=display:flex><span><span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>my_attrset<span style=color:#f92672>.</span>foo
</span></span></code></pre></div><ul><li>Output:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span><span style=color:#e6db74>&#34;bar&#34;</span>
</span></span></code></pre></div></li><li><p><strong>Top-Level Attributes of a Flake</strong>:</p><ul><li>Flakes have specific top-level attributes that can be accessed directly
(without dot notation). The most common ones are inputs, outputs, and
nixConfig.</li></ul></li></ul><h3 id=anatomy-of-flakenix>Anatomy of <code>flake.nix</code><a hidden class=anchor aria-hidden=true href=#anatomy-of-flakenix>#</a></h3><p><strong><code>inputs</code>: Declaring Dependencies</strong></p><ul><li><p>The <strong><code>inputs</code></strong> attribute set specifies the other flakes that your current
flake depends on.</p></li><li><p>Each key in the <strong><code>inputs</code></strong> set is a name you choose for the dependency, and
the value is a reference to that flake (usually a URL or a Git Repo).</p></li><li><p>To access something from a dependency, you generally go through the <code>inputs</code>
attribute (e.g., <code>inputs.helix.packages</code>).</p><ul><li><strong>Example:</strong> This declares dependencies on the <code>nixpkgs</code> and <code>import-cargo</code>
flakes:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>inputs <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  import-cargo<span style=color:#f92672>.</span>url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;github:edolstra/import-cargo&#34;</span>;
</span></span><span style=display:flex><span>  nixpkgs<span style=color:#f92672>.</span>url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;nixpkgs&#34;</span>;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><ul><li><p>When Nix evaluates your flake, it fetches and evaluates each input. These
evaluated inputs are then passed as an attribute set to the outputs
function, with the keys matching the names you gave them in the inputs set.</p></li><li><p>The special input self is a reference to the outputs and the source tree of
the current flake itself.</p></li></ul></li></ul><p><strong><code>outputs</code>: Defining What Your Flake Provides</strong></p><ul><li><p>The <strong><code>outputs</code></strong> attribute defines what your flake makes available. This can
include packages, NixOS modules, development environments (<code>devShells</code>) and
other Nix derivations.</p></li><li><p>Flakes can output arbitrary Nix values. However, certain outputs have specific
meanings for Nix commands and must adhere to particular types (often
derivations, as described in the
<a href=https://nixos.wiki/wiki/Flakes>output schema</a>).</p></li><li><p>You can inspect the outputs of a flake using the command:</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>nix flake show
</span></span></code></pre></div><blockquote><p>This command takes a flake URI and displays its outputs in a tree structure,
showing the attribute paths and their corresponding types.</p></blockquote><p><strong>Understanding the <code>outputs</code> Function</strong></p><ul><li><p>Beginners often mistakenly think that self and nixpkgs within
<code>outputs = { self, nixpkgs, ... }: { ... }</code> are the outputs themselves.
Instead, they are the <em>input arguments</em> (often called <em>output arguments</em>) to
the outputs function.</p></li><li><p>The outputs function in <code>flake.nix</code> always takes a single argument, which is
an attribute set. The syntax <code>{ self, nixpkgs, ... }</code> is Nix&rsquo;s way of
destructuring this single input attribute set to extract the values associated
with the keys self and nixpkgs.</p></li></ul><p><strong>Referencing the Current Flake</strong> (<code>self</code>)</p><ul><li><p><code>self</code> provides a way to refer back to the current flake from within the
outputs function. You can use it to access other top-level attributes like
inputs (e.g., <code>self.inputs</code>).</p></li><li><p>The outputs function always receives an argument conventionally named self,
which represents the entire flake, including all its top-level attributes.
You&rsquo;ll typically use self to reference things defined within your own flake
(e.g., <code>self.packages.my-package</code>).</p></li></ul><p><strong>Variadic Attributes (&mldr;) and @-patterns</strong></p><ul><li><p>The <code>...</code> syntax in the input arguments of the outputs function indicates
variadic attributes, meaning the input attribute set can contain more
attributes than just those explicitly listed (like <code>self</code> and <code>nixpkgs</code>).</p><p><strong>Example:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>mul <span style=color:#f92672>=</span> { a<span style=color:#f92672>,</span> b<span style=color:#f92672>,</span> <span style=color:#f92672>...</span> }: a <span style=color:#960050;background-color:#1e0010>\</span><span style=color:#f92672>*</span> b;
</span></span><span style=display:flex><span>mul { a <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>; b <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>; c <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; } <span style=color:#75715e># &#39;c&#39; is an extra attribute</span>
</span></span></code></pre></div><p>However, you cannot directly access these extra attributes within the function
body unless you use the @-pattern:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>mul <span style=color:#f92672>=</span> s<span style=color:#f92672>@</span>{ a<span style=color:#f92672>,</span> b<span style=color:#f92672>,</span> <span style=color:#f92672>...</span> }: a _ b _ s<span style=color:#f92672>.</span>c; <span style=color:#75715e># &#39;s&#39; now refers to the entire input set</span>
</span></span><span style=display:flex><span>mul { a <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>; b <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>; c <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; } <span style=color:#75715e># Output: 24</span>
</span></span></code></pre></div><ul><li><p>When used in the outputs function argument list (e.g.,
<code>outputs = { pkgs, ... } @ inputs)</code>, the @-pattern binds the entire input
attribute set to a name (in this case, <code>inputs</code>) while also allowing you to
destructure specific attributes like pkgs.</p></li><li><p><strong>What <code>outputs = { pkgs, ... } @ inputs: { ... };</code> does:</strong></p></li></ul></li></ul><ol><li><p><strong>Destructuring:</strong> It tries to extract the value associated with the key
<code>pkgs</code> from the input attribute set and binds it to the variable <code>pkgs</code>. The
<code>...</code> allows for other keys in the input attribute set to be ignored during
this direct destructuring.</p></li><li><p><strong>Binding the Entire Set:</strong> It binds the entire input attribute set to the
variable inputs.</p><ul><li>Example <code>flake.nix</code>:</li></ul></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>{
</span></span><span style=display:flex><span>inputs<span style=color:#f92672>.</span>nixpkgs<span style=color:#f92672>.</span>url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;github:NixOS/nixpkgs/nixos-unstable&#34;</span>;
</span></span><span style=display:flex><span>inputs<span style=color:#f92672>.</span>home-manager<span style=color:#f92672>.</span>url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;github:nix-community/home-manager&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>outputs <span style=color:#f92672>=</span> { self<span style=color:#f92672>,</span> nixpkgs<span style=color:#f92672>,</span> <span style=color:#f92672>...</span> } <span style=color:#f92672>@</span> attrs: { <span style=color:#75715e># A `packages` output for the x86_64-linux platform</span>
</span></span><span style=display:flex><span>packages<span style=color:#f92672>.</span>x86_64-linux<span style=color:#f92672>.</span>hello <span style=color:#f92672>=</span> nixpkgs<span style=color:#f92672>.</span>legacyPackages<span style=color:#f92672>.</span>x86_64-linux<span style=color:#f92672>.</span>hello;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># A `nixosConfigurations` output (for a NixOS system named &#34;fnord&#34;)</span>
</span></span><span style=display:flex><span>    nixosConfigurations<span style=color:#f92672>.</span>fnord <span style=color:#f92672>=</span> nixpkgs<span style=color:#f92672>.</span>lib<span style=color:#f92672>.</span>nixosSystem {
</span></span><span style=display:flex><span>      system <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;x86_64-linux&#34;</span>;
</span></span><span style=display:flex><span>      specialArgs <span style=color:#f92672>=</span> attrs;
</span></span><span style=display:flex><span>      modules <span style=color:#f92672>=</span> [ <span style=color:#e6db74>./configuration.nix</span> ];
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Platform Specificity in Outputs</strong></p><ul><li>Flakes ensure that their outputs are consistent across different evaluation
environments. Therefore, any package-related output must explicitly specify
the target platform (a combination of architecture and OS, <code>x86_64-linux</code>).</li></ul><p><strong>legacyPackages Explained</strong></p><ul><li><code>legacyPackages</code> is a way for flakes to interact with the traditional, less
structured package organization of nixpkgs. Instead of packages being directly
at the top level (e.g., <code>pkgs.hello</code>), <code>legacyPackages</code> provides a
platform-aware way to access them within the flake&rsquo;s structured output format
(e.g., <code>nixpkgs.legacyPackages.x86_64-linux.hello</code>). It acts as a bridge
between the flake&rsquo;s expected output structure and nixpkgs&rsquo;s historical
organization.</li></ul><p><strong>The Sole Argument of outputs</strong></p><ul><li>It&rsquo;s crucial to remember that the outputs function accepts only one argument,
which is an attribute set. The <code>{ self, nixpkgs, ... }</code> syntax is simply
destructuring that single input attribute set.</li></ul><p><strong>Outputs of the Flake (Return Value)</strong></p><ul><li>The outputs of the flake refer to the attribute set that is returned by the
<code>outputs</code> function. This attribute set can contain various named outputs like
<code>packages</code>, <code>nixosConfigurations</code>, <code>devShells</code>, etc.</li></ul><p><strong>Imports: Including Other Nix Expressions</strong></p><ul><li><p>The <code>import</code> function in Nix is used to evaluate the Nix expression found at a
specified path (usually a file or directory) and return its value.</p></li><li><p>Basic Usage: import <code>./path/to/file.nix</code></p></li></ul><p><strong>Passing Arguments During Import</strong></p><ul><li>You can also pass an attribute set as an argument to the Nix expression being
imported:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span><span style=color:#66d9ef>let</span>
</span></span><span style=display:flex><span>myHelpers <span style=color:#f92672>=</span> <span style=color:#f92672>import</span> <span style=color:#e6db74>./lib/my-helpers.nix</span> { pkgs <span style=color:#f92672>=</span> nixpkgs; };
</span></span><span style=display:flex><span><span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span><span style=color:#75715e># ... use myHelpers</span>
</span></span></code></pre></div><ul><li>In this case, the Nix expression in <code>./lib/my-helpers.nix</code> is likely a
function that expects an argument (often named <code>pkgs</code> by convention):</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span><span style=color:#75715e># ./lib/my-helpers.nix</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>{ pkgs }:
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span>
</span></span><span style=display:flex><span>myPackage <span style=color:#f92672>=</span> pkgs<span style=color:#f92672>.</span>stdenv<span style=color:#f92672>.</span>mkDerivation {
</span></span><span style=display:flex><span>name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;my-package&#34;</span>; <span style=color:#75715e># ...</span>
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>myPackage
</span></span></code></pre></div><ul><li>By passing <code>{ pkgs = nixpkgs; }</code> during the import, you are providing the
nixpkgs value from your current <code>flake.nix</code> scope to the pkgs parameter
expected by the code in <code>./lib/my-helpers.nix</code>.</li></ul><p><strong>Importing Directories (<code>default.nix</code>)</strong></p><ul><li>When you use import with a path that points to a directory, Nix automatically
looks for a file named <code>default.nix</code> within that directory. If found, Nix
evaluates the expressions within <code>default.nix</code> as if you had specified its
path directly in the import statement.</li></ul><h4 id=further-resources>Further Resources<a hidden class=anchor aria-hidden=true href=#further-resources>#</a></h4><ul><li><p><a href=https://serokell.io/blog/practical-nix-flakes>practical-nix-flakes</a></p></li><li><p><a href=https://www.tweag.io/blog/2020-07-31-nixos-flakes/>tweag nix-flakes</a></p></li><li><p><a href=https://nixos.wiki/wiki/Flakes>NixOS-wiki Flakes</a></p></li><li><p><a href=https://nix.dev/concepts/flakes.html>nix.dev flakes</a></p></li><li><p><a href=https://jade.fyi/blog/flakes-arent-real/>flakes-arent-real</a></p></li><li><p><a href=https://mhwombat.codeberg.page/nix-book/#_attribute_set_operations>wombats-book-of-nix</a></p></li><li><p><a href=https://zero-to-nix.com/concepts/flakes/>zero-to-nix flakes</a></p></li><li><p><a href=https://nixos-and-flakes.thiscute.world/>nixos-and-flakes-book</a></p></li><li><p><a href=https://flakehub.com/>FlakeHub</a></p></li></ul></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://tsawyer87.github.io/>NixOS Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>